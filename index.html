<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxen</title>
<style>
    /* =========================================
       1. VARIABLES & THEME
       ========================================= */
    :root {
        /* Palette */
        --bg-body: #0c1120f2;       /* Dark Navy */
        --bg-card: #242d42f2;       /* Slate */
        --bg-input: #323a4d;
        --primary: #676bd6;         /* Indigo */
        --primary-light: #818cf8;
        --secondary: #66b1ee;       /* Teal */
        --danger: #ef4444;          /* Red */
        --warning: #f59e0b;         /* Amber */
        
        /* Text */
        --text-main: #f1f5f9;
        --text-muted: #a4b5cc;
        
        /* UI Tokens */
        --border-radius: 32px;
        --round: 50px;
        --shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.5);
        --trans: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        
        /* State */
        --glow-speed: 0.1s; 
    }

    /* =========================================
       2. GLOBAL RESET & BASE STYLES
       ========================================= */
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background-color: var(--bg-body);
        color: var(--text-main);
        margin: 0;
        padding: 2vh 2vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        overflow: hidden; 
    }

    /* Custom Scrollbars */
    ::-webkit-scrollbar { width: 5px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { 
        background: rgba(255, 255, 255, 0.15); 
        border-radius: 4px; 
    }
    ::-webkit-scrollbar-thumb:hover { background: var(--primary); }

    /* =========================================
       3. MAIN LAYOUT
       ========================================= */
    .app-container {
        width: 100%;
        max-width: 1600px;
        height: 96vh;
        background-color: var(--bg-card);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        display: flex;
        overflow: hidden;
        position: relative;
    }

    /* =========================================
       4. SIDEBAR (SETTINGS)
       ========================================= */
    .sidebar {
        position: absolute;
        top: 20px;
        left: 20px;
        bottom: 20px;
        width: 450px;
        background-color: #161d2b;
        display: flex;
        flex-direction: column;
        padding: 0;
        z-index: 300;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
        border-radius: 24px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        overflow: hidden;
        
        /* Hidden state (PC) */
        transform: translateX(-110%);
        opacity: 0;
        pointer-events: none;
    }

    .sidebar.active {
        transform: translateX(0);
        opacity: 1;
        pointer-events: auto;
    }

    .sidebar-container {
        background-color: #1c2436;
        margin-top: 10px;
        border-radius: 0px;
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
    }

    .sidebar-inner {
        padding: 1.5rem;
        display: flex; 
        flex-direction: column; 
        height: 100%;
        overflow-y: auto;
    }

    /* PC Overlay */
    .sidebar-overlay-pc {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(2px);
        z-index: 250;
        opacity: 0; pointer-events: none;
        transition: opacity 0.3s;
    }
    .sidebar.active ~ .sidebar-overlay-pc { opacity: 1; pointer-events: auto; }

    /* Sidebar Components */
    .brand {
        font-size: 1.4rem;
        font-weight: 800;
        color: var(--text-main);
        margin-bottom: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .brand span { color: var(--primary-light); }

    .section-title {
        color: var(--text-muted);
        font-size: 0.75rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-top: 2.0rem;
        margin-bottom: 0.5rem;
        padding-bottom: 1px;
    }
    .section-title:first-of-type { margin-top: 0.5rem; }

    /* Sidebar Tabs */
    .sidebar-tabs {
        display: flex;
        gap: 5px;
        padding: 15px 15px 0 15px;
    }

    .tab-btn {
        flex: 1;
        background: rgba(255,255,255,0.02);
        border: none;
        color: var(--text-muted);
        padding: 12px;
        font-weight: 700;
        font-size: 0.8rem;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        transition: var(--trans);
        border-radius: 25px;
        margin-bottom: 10px;
    }
    .tab-btn:hover { color: var(--text-main); background: rgba(255,255,255,0.05); }
    .tab-btn.active { color: var(--primary-light); }

    .tab-content {
        display: none;
        flex-direction: column;
        gap: 15px;
        padding-top: 20px;
        animation: fadeIn 0.3s ease;
    }
    .tab-content.active { display: flex; }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    /* =========================================
       5. FORMS & INPUTS
       ========================================= */
    .input-group { margin-bottom: 1.2rem; }
    .label-row, .label-row2 { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-bottom: 0.4rem; 
        font-size: 0.75rem;
        font-weight: 800;
        text-transform: capitalize;
    }
    
    label { 
        display: block; color: var(--text-muted); font-size: 0.75rem; font-weight: 700; margin: 0;
    }

    textarea, input[type="text"], input[type="number"], select {
        width: 100%;
        background: var(--bg-input);
        border: 2px solid transparent;
        color: white;
        padding: 0.6rem;
        border-radius: 8px;
        font-family: inherit;
        transition: var(--trans);
    }
    textarea:focus, input:focus { outline: none; border-color: var(--primary); background: #242c3ff2; }

    /* Number Input Clean-up */
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }

    /* Specific Textareas */
    textarea { height: 200px; resize: none; font-family: 'JetBrains Mono', 'Inter', monospace; font-size: 0.85rem; font-weight: bold; }
    .sidebar textarea { height: 300px; font-size: 0.8rem; line-height: 1.5; }
    .expanded-textarea {
        flex: 1; background: #0f172a; border: 1px solid rgba(255,255,255,0.1);
        color: var(--text-main); padding: 1rem; font-family: 'JetBrains Mono', 'Inter', monospace; font-weight: bold;
        border-radius: 8px; margin-bottom: 1rem; font-size: 1rem; line-height: 1.6; resize: none;
    }

    /* Mode Toggles (Radio) */
    .mode-toggle { display: flex; background: var(--bg-input); padding: 4px; border-radius: var(--round); }
    .mode-toggle label {
        flex: 1; text-align: center; padding: 16px; margin: 0; cursor: pointer;
        border-radius: var(--round); color: var(--text-muted); transition: var(--trans);
    }
    input[type="radio"] { display: none; }
    input[type="radio"]:checked + label { background-color: var(--primary); color: white; }

    /* File Upload Custom */
    .file-upload-wrapper { position: relative; width: 100%; height: 65px; margin-bottom: 10px; }
    .load-project-wrapper { position: relative; width: 100%; height: 45px; margin-bottom: 10px; }
    
    .file-upload-input { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 2; }
    .file-upload-label {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255,255,255,0.05);
        border: 1.5px dashed var(--text-muted);
        border-radius: var(--round);
        display: flex; align-items: center; justify-content: center; gap: 8px;
        color: var(--text-muted); font-size: 0.85rem; transition: var(--trans); z-index: 1;
    }
    .file-upload-input:hover + .file-upload-label {
        background: rgba(99, 102, 241, 0.1); border-color: var(--primary); color: var(--primary-light);
    }

    /* =========================================
       6. BUTTONS
       ========================================= */
    .btn {
        background-color: var(--primary); color: white; border: none; padding: 1.0rem;
        border-radius: var(--round); cursor: pointer; font-weight: 600; width: 100%;
        transition: var(--trans); display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    .btn:hover { background: #a9b1ff; }
    .btn:active { transform: scale(0.98); }
    
    .btn-outline { background: #323a4d44; color: var(--text-muted); }
    .btn-outline:hover { background: #4a557044; }
    
    .btn-secondary { background: var(--bg-input); color: var(--text-main); }
    .btn-secondary:hover { background: #4a5570; }

    .btn-note { width: 48px; height: 48px; padding: 0; flex-shrink: 0; }
    
    .expand-btn {
        background-color: var(--bg-card); color: rgb(183, 185, 209);
        border: none; border-radius: 5px; font-size: 1rem; padding: 1px 5px;
        cursor: pointer; transition: var(--trans);
        display: flex; align-items: center; justify-content: center;
    }
    .expand-btn:hover { background-color: var(--primary-light); transform: translateY(-1px); }

    /* Header Buttons */
    .header-btn {
        background: transparent; color: var(--text-muted); padding: 6px 12px;
        border-radius: var(--round); font-size: 0.85rem; cursor: pointer;
        transition: var(--trans); display: flex; align-items: center; gap: 6px; height: 40px; border: none;
    }
    .header-btn:hover { background: rgba(255,255,255,0.1); color: white; }
    .header-btn:disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }

    /* Specific Header Button States */
    #edit-mode-toggle.active, #edit-mode-toggle-mobile.active { 
        background: var(--warning) !important; color: #0f172a !important; font-weight: bold; 
    }
    #preview-btn.active, #mobile-preview-btn.active { 
        background: var(--secondary); color: #0f172a; font-weight: bold; 
    }

    /* =========================================
       7. EDITOR AREA
       ========================================= */
    .editor-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        /*background: radial-gradient(circle at top right, #2d3748 0%, transparent 40%);*/
        overflow: hidden;
    }

    /* Top Information Bar */
    .top-info-bar {
        position: absolute; top: 0; left: 0px; width: 100%; height: 80px;
        background: rgba(30, 41, 59, 0.5); backdrop-filter: blur(10px);
        padding: 0.5rem 1.5rem;
        display: flex; justify-content: space-between; align-items: center;
        z-index: 50;
    }

    .time-display {
    font-family: 'Courier New', monospace; 
    font-size: 1.5rem; 
    font-weight: 700;
    color: var(--secondary); 
    text-align: center; 
    will-change: content;
    
    /* Center Absolute on PC */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    pointer-events: none; /* Let clicks pass through to potential elements below if needed */
}
    .top-right-controls { display: flex; gap: 10px; align-items: center; justify-content: flex-end;}
    .top-left-controls { display: flex; gap: 10px; align-items: center; }
    .mobile-header-right, .mobile-dock-controls, .mobile-header-left { display: none; }

    /* Lyrics List Container */
    .lyrics-list {
        flex: 1;
        overflow-y: auto;
        padding: 80px 1rem 60vh 1rem; 
        scroll-behavior: smooth;
        transform: translateZ(0);
    }

    /* Lyric Lines */
    .lyric-line {
        display: flex; align-items: flex-start;
        padding: 0.8rem; margin-bottom: 0.5rem; margin-left: 1.0rem;
        border-radius: 8px; border-left: 4px solid transparent;
        background: rgba(255,255,255,0.02);
        transition: opacity 0.3s ease, transform 0.3s ease; 
        position: relative; will-change: opacity, transform;
    }
    
    .lyric-line.active {
        background: rgba(99, 102, 241, 0.15);
        border-left-color: var(--primary-light);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }


/* =======================================
   Timestamp Styling
   =======================================*/
   
       /* Line Components */
    .line-meta {
  display: flex;
  align-items: center;      /* vertical center */
  justify-content: flex-start; /* left side */
  margin-right: 12px;
  margin-top: 4px;
  height: 100%;
}

   /* --- NEW TIMESTAMP STYLES --- */
    .timestamp-group {
        display: flex;
    align-items: center;
    justify-content: center;
    align-self: center;
        gap: 2px;
        font-family: monospace;
        background: rgba(0, 0, 0, 0.1);
        padding: 8px 6px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .timestamp-group:hover {
        border-color: var(--primary-light);
    }

    .ts-digit {
        background: transparent;
        border: none;
        color: var(--secondary);
        font-family: inherit;
        font-size: 0.8rem;
        width: 20px;
        padding: 0;
        text-align: center;
        appearance: textfield;
        -moz-appearance: textfield;
    }
    
    .ts-digit:focus {
        outline: none;
        color: white;
        background: rgba(255,255,255,0.1);
        border-radius: 2px;
    }

    .ts-digit::-webkit-outer-spin-button,
    .ts-digit::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }

    .ts-sep {
        color: var(--text-muted);
        opacity: 0.5;
        font-size: 0.8rem;
    }
    
    /* Disable interaction in preview mode */
    .app-container.is-preview .timestamp-group {
        pointer-events: none;
        opacity: 0.7;
    }

    .line-content-wrapper { flex: 1; margin-left: 12px; margin-right: 65px; }
    .line-text {
        font-size: 1.05rem; line-height: 2.0; color: var(--text-main);
        padding: 4px 4px; border: 1px solid transparent; border-radius: 4px;
    }
    .line-text[contenteditable="true"] { cursor: default; outline: none; background: transparent; border: none; }

    /* Background Vocals */
    .lyric-line.is-bg-vocal .line-text { font-size: 0.85em; opacity: 0.6; font-style: italic; color: var(--primary-light); }
    .lyric-line.is-bg-vocal .timestamp-input { opacity: 0.5; }

    /* Inline Action Buttons */
    .line-actions {
        display: none; /* Hidden by default */
        position: absolute; right: 10px; top: 50%;
        transform: translateY(-50%); gap: 6px; z-index: 10;
    }
    .app-container.is-editing .line-actions { display: flex; }
    
    .action-btn {
        background: rgba(255,255,255,0.1); border: none; color: var(--text-muted);
        width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
        display: flex; align-items: center; justify-content: center; font-size: 12px;
    }
    .action-btn:hover { background: var(--primary); color: white; }

    /* Word Elements */
    .word-span {
        padding: 0px 6px; border-radius: 4px; cursor: pointer;
        margin-bottom: 8px; user-select: none; display: inline-block;
        transition: color var(--glow-speed) ease-out, background var(--glow-speed) ease-out,
                    text-shadow var(--glow-speed) ease-out, transform var(--glow-speed) ease-out;
    }
    .word-span.synced { color: var(--secondary); background: rgba(20, 184, 166, 0.1); }
    .word-span.active-word { 
        background: var(--primary); color: white; transform: scale(1.1); 
        box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-weight: bold;
    }
    .word-span.preview-glow {
        color: #ffffff !important;
        text-shadow: 0 0 12px rgba(82, 192, 255, 0.959), 0 0 25px rgba(255, 255, 255, 0.3);
        font-weight: bold;
    }
    .app-container:not(.is-editing) .word-span:hover { background: rgba(255,255,255,0.1); }

    /* Word Context Floating UI */
    #word-context-ui {
        position: fixed; bottom: 200px; left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(15, 23, 42, 0.534);
        padding: 10px 20px; border-radius: 12px;
        display: flex; align-items: center; gap: 15px; opacity: 0;
        backdrop-filter: blur(16px); pointer-events: none; transition: var(--trans); z-index: 90;
    }
    #word-context-ui.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
    
    .ctx-prev { color: var(--secondary); font-size: 1.2rem; font-weight: 800; }
    .ctx-arrow { color: var(--text-muted); }
    .ctx-curr { color: var(--text-muted); font-weight: 800; font-size: 1.2rem; transform: scale(1.1); opacity: 0.6; }
    
    /* Hold Mode Context Styling */
    #word-context-ui.mode-hold .ctx-prev {
        color: var(--secondary); transform: scale(1.2); opacity: 1;
        text-shadow: 0 0 10px rgba(102, 177, 238, 0.3);
    }
    #word-context-ui.mode-hold .ctx-curr {
        color: var(--text-muted); transform: scale(1.0); opacity: 0.6; text-shadow: none; font-weight: 600;
    }

    /* =========================================
       8. CONTROL DOCK
       ========================================= */
    .control-dock {
        position: fixed; bottom: 19px; left: 50%; transform: translateX(-50%);
        width: 95%; max-width: 650px;
        background: #171e30;
        border-radius: 24px;
        padding: 20px 20px;
        display: flex; flex-direction: column; gap: 12px;
        box-shadow: 0 0px 24px rgba(0, 0, 0, 0.1); z-index: 200;
        transition: transform 0s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0s linear;
    }
    
    .control-dock.active-hold-glow {
        box-shadow: 0 0 15px rgba(103, 107, 214, 0.6), inset 0 0 20px rgba(103, 107, 214, 0.2) !important;
        border-color: rgba(129, 140, 248, 0.5);
    }

    /* Sliders */
    .dock-row-slider2 { display: flex; align-items: center; gap: 50px; width: 100%; }
    .seek-time { font-family: monospace; font-size: 0.75rem; color: var(--text-muted); min-width: 40px; text-align: center; }
    #dur-time-lbl { margin-left: auto; }

    input[type=range] { -webkit-appearance: none; background: transparent; cursor: pointer; padding: 0; margin: 0; border: none; }
    input[type=range]:focus { outline: none; }
    
    .seek-slider { flex: 1; width: 100%; height: 6px; border-radius: 4px; }
    .seek-slider::-webkit-slider-runnable-track { width: 100%; height: 6px; border-radius: 4px; background: transparent; cursor: pointer; }
    .seek-slider::-webkit-slider-thumb {
        -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
        background: var(--primary); margin-top: -5px; 
        box-shadow: 0 0 10px rgba(99, 102, 241, 0.5); transition: transform 0.1s;
    }
    .seek-slider::-webkit-slider-thumb:active { transform: scale(1.3); }

    /* Player Controls */
    .dock-row-controls { display: flex; position: relative; align-items: center; justify-content: center; }
    .player-controls { display: flex; align-items: center; gap: 4px; flex: 1; justify-content: center; }

    .control-btn {
        background: transparent; border: none; color: var(--text-main);
        width: 50px; height: 50px; border-radius: 50%; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        transition: var(--trans); font-size: 1.2rem;
    }
    .control-btn:hover { background: rgba(255,255,255,0.1); }
    .control-btn:active { transform: scale(0.9); }
    
    .play-btn { 
        background: var(--text-main); color: var(--bg-body); 
        width: 60px; height: 60px; font-size: 1.4rem; border-radius: var(--round);
    }
    .play-btn:hover { background: white; transform: scale(1.05); }

    /* Dock Buttons */
    .dock-sync-btn {
        background: var(--secondary); color: #0f172a; border: none; font-weight: 800;
        height: 54px; padding: 0 24px; border-radius: var(--round); cursor: pointer;
        display: flex; align-items: center; gap: 8px;
        box-shadow: 0 0px 0px rgba(20, 184, 166, 0.3); transition: transform 0.1s;
    }
    .dock-sync-btn:active { transform: scale(0.95); }
    .dock-sync-btn.holding { transform: scale(0.90); filter: brightness(0.8); }
    .dock-sync-btn span { font-size: 1.4rem; }
    .dock-sync-btn div { font-size: 0.9rem; font-weight: 900; text-transform: uppercase; letter-spacing: 1px; }

    .dock-settings-trigger {
        background: rgba(255,255,255,0.05); color: var(--text-muted); border: none;
        width: 54px; height: 54px; border-radius: var(--round); margin: 0 16px 0 0px;
        cursor: pointer; display: flex; align-items: center; justify-content: center;
        transition: var(--trans);
    }
    .dock-settings-trigger:hover { background: rgba(255,255,255,0.1); color: white; }

    /* Popups (Speed/Volume) */
    .popup-wrapper { position: relative; }
    .dock-popup {
        position: absolute; bottom: 140%; left: 50%; transform: translateX(-50%) translateY(10px);
        background: var(--bg-card); border: 1px solid rgba(255,255,255,0.1);
        border-radius: 12px; padding: 6px; display: flex; flex-direction: column;
        gap: 4px; opacity: 0; pointer-events: none; transition: var(--trans);
        box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 101;
    }
    .dock-popup.active { opacity: 1; pointer-events: auto; transform: translateX(-50%) translateY(0); }
    
    .speed-toggle-btn { font-size: 0.8rem; font-weight: 700; color: var(--text-muted); width: auto; padding: 0 8px; }
    .speed-option {
        background: transparent; border: none; color: var(--text-muted); padding: 8px 12px;
        border-radius: 6px; cursor: pointer; font-size: 0.85rem; text-align: center;
    }
    .speed-option.selected { background: var(--primary); color: white; }
    
    .vol-slider { width: 100px; height: 6px; transform: rotate(-90deg); border-radius: 4px; margin: 0; }
    .vol-slider::-webkit-slider-runnable-track { width: 100px; height: 6px; border-radius: 4px; background: transparent; }
    .vol-slider::-webkit-slider-thumb {
        -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
        background: var(--primary); margin-top: -5px;
    }
    .volume-popup { height: 140px; width: 50px; display: flex; align-items: center; justify-content: center; }

    /* =========================================
       9. MODALS
       ========================================= */
    .modal-overlay {
        position: fixed; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); z-index: 500;
        display: flex; align-items: center; justify-content: center;
        opacity: 0; pointer-events: none; transition: var(--trans);
    }
    .modal-overlay.active { opacity: 1; pointer-events: auto; }
    
    .base-modal {
        background: var(--bg-card); border-radius: 16px;
        padding: 24px; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        border: 1px solid rgba(255,255,255,0.1);
    }
    .modal-title { font-size: 1.1rem; font-weight: 800; margin-bottom: 16px; text-align: center; }
    
    /* Specific Modal Sizes */
    .offset-modal, .sync-settings-modal { width: 340px; }
    .expanded-text-modal { width: 800px; max-width: 90%; height: 80vh; display: flex; flex-direction: column; }
    
    /* Modal Interactions */
    .offset-grid { display: flex; gap: 8px; margin-bottom: 20px; }
    .offset-col { flex: 1; }
    .offset-col label { font-size: 0.7rem; text-align: center; display: block; }
    
    /* Edit List Modal */
    #edit-word-list { max-height: 300px; overflow-y: auto; margin-top: 15px; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; }
    .edit-word-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; padding: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .edit-word-text { flex: 1; color: var(--text-main); font-weight: 600; }
    .edit-timestamp {
        background: var(--bg-input); border: 1px solid rgba(255,255,255,0.1);
        color: var(--primary-light); width: 80px; padding: 4px;
        border-radius: 4px; font-family: monospace; font-size: 0.85rem;
    }
    
    /* Sync Settings Items */
    .sync-option-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 16px; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px;
    }
    .sync-option-label { font-size: 0.9rem; font-weight: 700; color: var(--text-main); margin-right: 10px; }
    .sync-option-sub { font-size: 0.75rem; color: var(--text-muted); margin-top: 2px; }
    
    .toggle-group {
        display: flex; background: var(--bg-input); padding: 3px; border-radius: 6px;
        flex-wrap: wrap; justify-content: flex-end; gap: 2px;
    }
    .toggle-opt {
        padding: 6px 12px; font-size: 0.75rem; font-weight: 600; cursor: pointer;
        border-radius: 4px; color: var(--text-muted); transition: var(--trans);
        user-select: none; text-align: center;
    }
    .toggle-opt.active { background: var(--primary); color: white; }
    .toggle-opt.disabled-mode { opacity: 0.4; pointer-events: none; cursor: not-allowed; background: transparent; }

    #glow-trigger { background: var(--bg-input); border: 0px; }
    #glow-trigger:hover { background: #68738f; }
    #custom-glow-input { width: 50%; margin-top: 3px; border: 1px solid rgba(255,255,255,0.1); padding: 5px; font-size: 0.9rem; display: none; text-align: center; margin-left: 20px; }
    #custom-glow-input.active { display: block; }
    #glow-speed-container.disabled { opacity: 0.3; pointer-events: none; }

    #expand-modal-actions { display: flex; gap: 10px; flex: 1; justify-content: flex-end; align-items: center; }
    #expand-modal-actions .btn:not(.btn-note) { flex: 1; }

    /* =========================================
       10. UTILITY & STATES
       ========================================= */
    .disabled-area {
        opacity: 0.3; pointer-events: none;
        transition: opacity 0.4s ease, filter 0.4s ease; user-select: none;
    }
    #edit-settings-btn { display: none; }
    
    /* Preview State Overrides */
    .app-container.is-preview .lyric-line { opacity: 0.2; transform: scale(0.99); }
    .app-container.is-preview .lyric-line.active { opacity: 1; transform: scale(1.02); background: rgba(99, 102, 241, 0.2); border-left-color: var(--secondary); z-index: 10; }
    .app-container.is-preview .lyric-line.active-bg-preview { opacity: 0.9 !important; transform: scale(0.98); background: rgba(102, 177, 238, 0.1); border-left: 4px solid var(--secondary); z-index: 5; }
    
    /* Edit State Overrides */
    .app-container.is-editing .lyric-line { border-left-color: var(--warning); background: rgba(245, 158, 11, 0.05); }
    .app-container.is-editing .lyric-line .timestamp-input { opacity: 0.3; }
    .app-container.is-editing #btn-add-top { display: inline-block !important; }

    /* View Filtering */
    .view-btn { opacity: 0.5; transition: all 0.2s ease; border: 1px solid transparent; }
    .view-btn:hover { opacity: 0.8; }
    .view-btn.active { opacity: 1; border-color: var(--primary); background-color: var(--primary); color: white; font-weight: bold; box-shadow: 0 0 15px rgba(99, 102, 241, 0.4); }
    
    .app-container.view-main .lyric-line.is-bg-vocal { display: none !important; }
    .app-container.view-bg .lyric-line:not(.is-bg-vocal) { display: none !important; }
     /* =========================================
       Welcome Container & Add New Line
       ========================================= */

/* Welcome Screen Styling */
.welcome-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 60vh;
    text-align: center;
    color: var(--text-main);
    animation: fadeIn 0.5s ease;
}

.welcome-title {
    font-size: 2rem;
    font-weight: 800;
    margin-bottom: 2rem;
    background: linear-gradient(to right, #fff, #94a3b8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.welcome-actions {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
}

.welcome-btn {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 15px 25px;
    border-radius: var(--round);
    color: var(--text-main);
    font-weight: 600;
    cursor: pointer;
    transition: var(--trans);
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 130px;
    justify-content: center;
}

.welcome-btn:hover:not(:disabled) {
    background: var(--primary);
    border-color: var(--primary);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3);
}

.welcome-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    filter: grayscale(1);
}

/* "Add New Line" Dashed Button */
.lyric-line.add-new-line-btn {
    border: 2px dashed rgba(255, 255, 255, 0.15);
    background: transparent !important;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    color: var(--text-muted);
    font-weight: 700;
    opacity: 0.7;
    margin-top: 15px;
    transition: var(--trans);
    padding: 1.2rem;
}

.lyric-line.add-new-line-btn:hover {
    border-color: var(--primary);
    color: var(--primary-light);
    opacity: 1;
    background: rgba(99, 102, 241, 0.05) !important;
}

.btn-delete {
        color: var(--danger) !important;
        background: rgba(239, 68, 68, 0.15) !important;
}

.btn-delete:hover {
        background: var(--danger) !important;
        color: white !important;
}

.app-container.is-preview .add-new-line-btn {
        pointer-events: none;
        opacity: 0.3;
        border-style: solid;
}

.export-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 15px;
}
.export-preview {
    width: 100%;
    height: 150px;
    background: var(--bg-input);
    color: var(--text-muted);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 10px;
    font-family: monospace;
    font-size: 0.8rem;
    resize: none;
    margin-bottom: 15px;
}

.app-container.is-preview .line-actions { display: none !important; }

    .top-right-controls .header-btn {
        background: #ffffff;
        color: black;
        font-weight: bold;
        border-radius: 50px;
        padding: 0 30px;
    }

    /* =========================================
       11. MOBILE RESPONSIVE
       ========================================= */
    @media (min-width: 901px) {
        .lyric-line:hover .line-actions { display: flex; }
        /* Hide top edit button on PC */
        #edit-mode-toggle { display: none !important; }
    }

    @media (max-width: 900px) {
        .app-container.is-editing .line-actions { display: flex; }
        body { padding: 0; height: 100vh; }
        .app-container { border-radius: 0; height: 100%; max-width: 100%; border: none; }
        
        /* Mobile Sidebar (Sheet) */
        .sidebar {
            position: fixed; top: auto; bottom: 0; left: 0;
            height: 85vh; width: 100%; padding: 15px;
            background: #161d2b;
            transform: translateY(100%);
            border-radius: 24px 24px 0 0;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.15);
            display: flex; flex-direction: column;
        }
        .sidebar.active { transform: translateY(0); }
        .sidebar-tabs { padding: 10px 10px 0 10px; }
        .sidebar-inner { padding: 1.5rem; overflow-y: auto; padding-bottom: 100px; }
        #mobile-close-sidebar { display: none; }

        /* Header Changes */
        .top-info-bar { display: flex !important; justify-content: flex-end; height: 60px; background: transparent; pointer-events: none; }
        .top-left-controls { display: none; }
        .top-right-controls { display: none; }
        .mobile-header-right { display: flex; pointer-events: auto; margin-right: -20px; z-index: 60; }
        .mobile-header-left { display: flex !important; pointer-events: none; z-index: 60; position: absolute; left: 0; top: 0; padding: 10px; }
        
        .mode-indicator {
            font-weight: 500; letter-spacing: 1px; color: var(--text-muted); opacity: 0.5;
            border-radius: 50px; background: transparent; padding: 0px 20px;
            font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; height: 40px;
        }

        .time-display {
            margin: 0; opacity: 1; font-size: 1.5rem; pointer-events: auto;
            text-align: center; color: var(--secondary); text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            position: absolute; left: 50%; transform: translateX(-50%);
        }

        .editor-area { height: 100%; width: 100%; }
        .line-actions { margin-left: 0; margin-top: 4px; flex-direction: row; right: 10px; gap: 4px; }
        
        /* Mobile Control Dock */
        .control-dock {
            position: fixed; left: 0px; right: 0; transform: none; max-width: 100vw;
            width: 100%; bottom: 0; padding: 32px 32px; gap: 25px;
            background: #171e30; backdrop-filter: blur(0px); border-radius: 0; border: 0px;
            box-sizing: border-box; z-index: 100;
            box-shadow: 0 0px 150px rgba(0, 0, 0, 0.315);
        }
        
        .dock-row-slider { padding: 0px 20px; gap: 0px; margin-bottom: -8px; }
        .seek-slider { flex: 1; width: 100%; height: 12px; border-radius: 50px; }
        .seek-slider::-webkit-slider-thumb { height: 40px; width: 13px; border-radius: 50px; margin-top: -17px; box-shadow: none; border: 4px solid #171e30; }
        .dock-row-slider2 { display: flex; align-items: center; gap: 5px; width: 100%; margin-bottom: -10px; padding: 0px 14px; }

        /* Hidden on Mobile */
        .dock-sync-btn, .dock-settings-trigger { display: none; }

        /* Mobile Specific Buttons */
        .mobile-dock-controls {
            display: flex; align-items: center; justify-content: center;
            gap: 3px; width: 100%; padding: 0 5px; box-sizing: border-box;
            margin-bottom: 1.25rem;
        }
        .mobile-dock-controls button { display: flex; align-items: center; justify-content: center; flex-shrink: 1; min-width: 0; }
        .action-btn { width: 28px; height: 28px; font-size: 14px; backdrop-filter: blur(4px); }

        .sync-btn {
            background: var(--secondary); color: #0f172a; font-weight: 800;
            border: 0px; padding: 30px 30px; font-size: 1.5rem; cursor: pointer;
            transition: var(--trans); display: flex; align-items: center; height: 40px;
            border-radius: 10px;
        }
        .sync-btn.holding { transform: scale(0.95); background: var(--primary-light); }
        
        /* Custom Header Button Styles for Mobile Dock */
        .header-btn {
            background: #1f2941; border: 0px; color: var(--text-muted);
            padding: 30px 25px; font-size: 1.0rem; cursor: pointer; margin-right: 0px;
            transition: var(--trans); display: flex; align-items: center; height: 40px;
            border-radius: 5px;
        }
        .header-btn:hover { background: #2e3b5c; color: white; }
        .header-btn:first-child { border-radius: 50px 0 0 50px; padding: 30px 30px; }
        
        #mobile-preview-btn { opacity: 0.75; }
        #mobile-preview-btn.active { background: #4a4f75; color: #ffffff; font-weight: bold; }
        
        /* Player Control Tweaks */
        .player-controls { display: flex; align-items: left; gap: 20px; flex: 1; justify-content: center; padding-bottom: 10px; }
        .control-btn { width: 40px; height: 40px; font-size: 20px; }
        .play-btn { width: 60px; height: 60px; font-size: 1.4rem; border-radius: var(--round); }
        
        /* Word Context Mobile */
        #word-context-ui {
            bottom: 320px; width: auto; max-width: 90%; min-width: 250px;
            justify-content: center;
        }

        /* Specific Button Radii */
        .mobile-header-right .header-btn { border-radius: 50px; margin: 8px 8px 8px 0; padding: 0px 13px; }
        #mobile-dock-settings { margin-left: 0.5rem; }
        #sync-mode-btn { margin-right: 2px; border-radius: 50px 15px 15px 50px; }
        #fullscreenBtn { border-radius: 15px 50px 50px 15px; }
        #main-sync-btn-mobile { border-radius: 8px 50px 50px 8px; }

        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.178); width: 2px; }
    }
</style>
</head>
<body>

<div class="app-container" id="app-container">
    
   <div class="sidebar" id="sidebar">
        <div class="brand" style="padding: 15px 20px 5px 20px; margin: 0; font-size: 1.1rem;">
            <div style="display:flex; align-items:center; gap:8px;"><span>‚ö°</span> Voxen</div>
            <button class="expand-btn" style="width:32px; height:32px; background:transparent;" onclick="toggleSettings(false)">‚úï</button>
        </div>

        <div class="sidebar-tabs">
    <button id="tab-btn-media" class="tab-btn active" onclick="switchTab('media')">Media</button>
    <button id="tab-btn-session" class="tab-btn disabled-area" onclick="switchTab('session')">Session</button>
    <button id="tab-btn-output" class="tab-btn disabled-area" onclick="switchTab('output')">Output</button>
</div>

<div class="sidebar-container">
        <div class="sidebar-inner">
            <div id="tab-media" class="tab-content active">
                <div class="section-title">Audio Source</div>
                <div class="file-upload-wrapper">
                    <input type="file" id="audio-file" accept="audio/*" class="file-upload-input">
                    <div class="file-upload-label" id="audio-file-label"><span>‚ûú] Upload MP3</span></div>
                </div>

            <div class="section-title disabled-area">Project File (.vxn)</div>
            <div id="media-project-section" class="disabled-area" style="display:flex; gap:8px;">
                <div class="load-project-wrapper" style="margin:0;">
                    <input type="file" id="project-upload" accept=".vxn" class="file-upload-input" onchange="loadProject(this)">
                    <div class="file-upload-label"><span>üìÅ Load Project</span></div>
                </div>
                <button class="btn btn-secondary" style="height:45px;" onclick="saveProject()">üíæ Save</button>
            </div>
        </div>

            <div id="tab-session" class="tab-content">
                <div class="input-group">
                    <div class="section-title">Input Lyrics</div>
                    <textarea id="raw-lyrics" placeholder="Paste your lyrics here...&#10;Line 1&#10;Line 2"></textarea>
                </div>

                <div class="input-group">
    <div class="section-title">Sync Mode</div>
    <div class="mode-toggle">
        <input type="radio" id="mode-line" name="mode" value="line">
        <label for="mode-line">Line</label>
        <input type="radio" id="mode-word" name="mode" value="word" checked>
        <label for="mode-word">Word</label>
    </div>
</div>
                
                <button class="btn" onclick="initializeEditor()">‚ñ∂ Create New Editor</button>
            </div>

            <div id="tab-output" class="tab-content">
                <div class="input-group">
                    <div class="section-title">Offset (MS)</div>
                    <input type="number" id="offset-val" value="-200" step="50">
                </div>

                <div class="input-group">
    <div class="section-title">Format</div>
    <div class="mode-toggle">
        <input type="radio" id="fmt-adv-sidebar" name="lrc-fmt" value="advanced" onchange="setLRCFormat('advanced')">
        <label for="fmt-adv-sidebar">Advanced</label>
        <input type="radio" id="fmt-pro-sidebar" name="lrc-fmt" value="pro" checked onchange="setLRCFormat('pro')">
        <label for="fmt-pro-sidebar">Pro</label>
    </div>
</div>

                <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); width:100%;">

                <div class="section-title">Output Lyrics</div>
                <textarea id="export-output" placeholder="[00:00.00] Output will appear here..." style="font-family: monospace;"></textarea>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                     <button class="btn btn-outline" onclick="generateLRC()">Update Text</button>
                     <button class="btn btn-secondary" onclick="copyLRC()">Copy Text</button>
                </div>
                
                <div class="label-row2" style="margin-top:10px;"><label>File Operations</label></div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
                    <input type="file" id="lrc-file-input" accept=".lrc,.txt" style="display:none;" onchange="handleLRCFile(this)">
                    <button class="btn btn-secondary" onclick="document.getElementById('lrc-file-input').click()">üìÇ Open</button>
                    <button class="btn btn-secondary" onclick="loadLRCFromSidebar()">Load Text</button>
                    <button class="btn" onclick="downloadLRC()">Save .lrc</button>
                </div>
            </div>
        </div>
        </div>
    </div>
    <div class="sidebar-overlay-pc" onclick="toggleSettings(false)"></div>

    <div class="editor-area">
        <div class="top-info-bar">
            <div class="mobile-header-left">
                <div id="mobile-mode-indicator" class="mode-indicator">Tap</div>
            </div>

            <div class="top-left-controls">
    <button class="header-btn" onclick="toggleSettings(true)">
        ‚ò∞ <span class="btn-text">Menu</span>
    </button>
    <button id="edit-mode-toggle" class="header-btn" onclick="toggleEditMode()">
        ‚úé <span class="btn-text">Edit</span>
    </button>
    <button id="btn-add-top" class="header-btn" style="margin-left: 0px; display: none;" onclick="addLineAtTop()">
        + Line
    </button>
    <button id="preview-btn" class="header-btn" onclick="togglePreviewMode()">
        ‚ñ∂ <span class="btn-text">Preview</span>
    </button>
    <button id="btn-top-offset" class="header-btn" onclick="openOffsetModal()">
        ‚è± <span class="btn-text">Offset</span>
    </button>
</div>

<div id="time-display" class="time-display">00:00.00</div>
<div class="mobile-header-right">
    <button class="header-btn" onclick="openExportModal()" title="Export">
        <span class="btn-text">‚≠≥</span>
    </button>

    <button class="header-btn" onclick="openViewModal()">
        <span class="btn-text">‚ô™</span>
    </button>
    <button id="sync-mode-btn" class="header-btn" onclick="openSyncSettings()">‚öô</button>
    <button class="header-btn fullscreen-btn" id="fullscreenBtn">‚õ∂</button>
</div>

<div class="top-right-controls">
     <button class="header-btn" id="export-btn" onclick="openExportModal()" title="Export">
        <span class="btn-text">‚≠≥ Export</span>
    </button>
</div>
</div>
        
        <audio id="audio-player"></audio>

        <div class="lyrics-list" id="lyrics-container">
            <div class="welcome-container">
               <div class="welcome-title">‚ö° Welcome to Voxen</div>
                <div class="welcome-actions">
                    <button class="welcome-btn" onclick="document.getElementById('audio-file').click()">
                        <span>üéµ</span> Select Song
                    </button>
                    <button class="welcome-btn" id="welcome-lrc-btn" style="opacity: 0.3; cursor: none;" onclick="">
                        <span>üìÇ</span> Open LRC
                    </button>
                    <button class="welcome-btn" onclick="initializeEmptyEditor()">
                         <span>üìù</span> Add Line
                    </button>
                    <button class="welcome-btn" onclick="window.open('https://github.com/Raqhael-ux/Voxen-LRC-Editor', '_blank')">
                         <span>üîó</span> Github
                    </button>
                    <button class="welcome-btn" style="min-width: 20px; padding: 0 20px;" onclick="window.open('https://github.com/Raqhael-ux/Voxen-LRC-Editor', '_blank')">
                         <span>?</span>
                    </button>
                </div>
                <div style="margin-top: 20px; font-size: 0.8rem; color: var(--text-muted); opacity: 0.5;">
                    <p>Load an audio file to enable LRC features.</p>
                    <a href="#" style="color: inherit; text-decoration: underline;">v8.1.1</a>
                </div>
            </div>
        </div>
    </div>

        <div id="word-context-ui">
            <span class="ctx-prev" id="ctx-prev-word">Previous</span>
            <span class="ctx-arrow">‚Üí</span>
            <span class="ctx-curr" id="ctx-next-word">Target Word</span>
        </div>

        <div class="control-dock">
            <div class="dock-row-slider">
                <input type="range" id="seek-slider" class="seek-slider" value="0" min="0" max="100" step="0.1">
            </div>
            <div class="dock-row-slider2">
                 <span class="seek-time" id="curr-time-lbl">0:00</span>
                 <span class="seek-time" id="dur-time-lbl">0:00</span>
            </div>
            <div class="dock-row-controls">
                <div class="dock-settings-trigger" onclick="openViewModal()">
                <span>üëÅ</span>
                </div>
                
                <div class="player-controls">
                    <div class="popup-wrapper">
                        <button class="control-btn speed-toggle-btn" id="speed-btn" onclick="toggleSpeedMenu()">1.0x</button>
                        <div class="dock-popup speed-popup" id="speed-popup">
                            <button class="speed-option" onclick="setSpeed(0.5)">0.5x</button>
                            <button class="speed-option" onclick="setSpeed(0.75)">0.75x</button>
                            <button class="speed-option selected" onclick="setSpeed(1.0)">1.0x</button>
                            <button class="speed-option" onclick="setSpeed(1.25)">1.25x</button>
                            <button class="speed-option" onclick="setSpeed(1.5)">1.5x</button>
                        </div>
                    </div>

                    <button class="control-btn" onclick="seekAudio(-5)">‚Ü∫</button>
                    <button class="control-btn play-btn" id="play-pause-btn" onclick="togglePlay()">‚ñ∂</button>
                    <button class="control-btn" onclick="seekAudio(5)">‚Üª</button>
                    
                    <div class="popup-wrapper volume-wrapper">
                        <button class="control-btn" id="vol-btn" onclick="toggleVolumeMenu()">·Ø§</button>
                        <div class="dock-popup volume-popup" id="volume-popup">
                            <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="1" 
                                   class="vol-slider" oninput="updateVolume(this.value)">
                        </div>
                    </div>
                </div>

                <button class="dock-settings-trigger" onclick="openSyncSettings()">
                    <span>‚öô</span>
                </button>

               <button class="dock-sync-btn" id="main-sync-btn">
                    <span>‚è±Ô∏é</span>
                    <div id="main-sync-btn-text">TAP</div>
                </button>
            </div>

             <div class="mobile-dock-controls">
                <button id="mobile-dock-settings" class="header-btn" onclick="toggleSettings(true)">‚öô</button>
                <button id="edit-mode-toggle-mobile" class="header-btn" onclick="toggleEditMode()">‚úé</button>
                <button id="edit-offset-btn" class="header-btn" onclick="openOffsetModal()">‚è±</button>
                <button id="mobile-preview-btn" class="header-btn" onclick="togglePreviewMode()">
                    ‚ñ∑
                </button>
                <button class="sync-btn" id="main-sync-btn-mobile"><div>+</div></button>
              </div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="sync-settings-modal">
    <div class="base-modal sync-settings-modal">
        <div class="modal-title">Sync Logic</div>
        
        <div class="sync-option-row">
            <div>
                <div class="sync-option-label">Sync Mode</div>
                <div class="sync-option-sub">Input Behavior</div>
            </div>
           <div class="toggle-group">
        <div class="toggle-opt active" id="opt-tap" onclick="setSyncInputMode('tap')">Tap</div>
        <div class="toggle-opt" id="opt-hold" onclick="setSyncInputMode('hold')">Hold</div>
        <div class="toggle-opt" id="opt-sync-auto" checked onclick="setSyncInputMode('auto')">Hybrid</div>
    </div>
        </div>

        <div class="sync-option-row">
            <div>
                <div class="sync-option-label">Preview Glow</div>
                <div class="sync-option-sub">Fade In Mode</div>
            </div>
            <div class="toggle-group">
                <div class="toggle-opt active" id="opt-custom" onclick="setGlowMode('custom')">Custom</div>
                <div class="toggle-opt" id="opt-auto" onclick="setGlowMode('auto')">Auto</div>
            </div>
        </div>

        <div class="sync-option-row" id="glow-speed-container">
            <div>
                <div class="sync-option-label">Glow Speed</div>
                <div class="sync-option-sub">Duration</div>
            </div>
            <div style="flex:1; display:flex; justify-content:flex-end; align-items:center; gap:8px;">
                     <input type="number" id="custom-glow-input" placeholder="0.1" step="0.1" onchange="setGlowSpeed(this.value, true)">
                <div class="popup-wrapper" style="width: 100%; display: flex; justify-content: flex-end;">
                     <div class="toggle-group">
                          <button class="toggle-opt active" id="glow-trigger" onclick="toggleGlowMenu()">0.1s ‚ñº</button>
                     </div>
                    <div class="dock-popup" id="glow-popup" style="bottom: auto; top: 100%; left: auto; right: 0; transform: none; width: 120px; z-index: 200;">
                        <button class="speed-option" onclick="setGlowSpeed(0.1)">0.1s</button>
                        <button class="speed-option" onclick="setGlowSpeed(0.25)">0.25s</button>
                        <button class="speed-option" onclick="setGlowSpeed(0.5)">0.5s</button>
                        <button class="speed-option" onclick="toggleCustomGlowInput()">Custom</button>
                    </div>
                </div>
            </div>
        </div>

        <button class="btn btn-secondary" onclick="closeSyncSettings()">Close</button>
    </div>
</div>

<div class="modal-overlay" id="offset-modal">
    <div class="base-modal offset-modal">
        <div class="modal-title">Bulk Offset Timestamp</div>
        <p style="text-align:center; color: var(--text-muted); font-size: 0.8rem; margin-top:-10px;">
            Shift all synced lines forward (positive) or backward (negative).
        </p>
        <div class="offset-grid">
            <div class="offset-col"><label>Min</label><input type="number" id="off-min" value="0" placeholder="0"></div>
            <div class="offset-col"><label>Sec</label><input type="number" id="off-sec" value="0" placeholder="0"></div>
            <div class="offset-col"><label>Ms</label><input type="number" id="off-ms" value="0" placeholder="0"></div>
        </div>
        <div style="display:flex; gap:10px;">
            <button class="btn btn-secondary" onclick="closeOffsetModal()">Cancel</button>
            <button class="btn" onclick="applyOffset()">Apply Offset</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="expand-modal">
    <div class="base-modal expanded-text-modal">
        <div class="modal-title" id="expand-modal-title">Edit</div>
        <textarea id="expand-textarea" class="expanded-textarea" spellcheck="false"></textarea>
        <div style="display:flex; gap:10px;">
            <button class="btn btn-secondary" style="flex:0.5" onclick="closeExpandModal()">Cancel</button>
            <div id="expand-modal-actions" style="display:flex; gap:10px; flex:1;"></div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="single-line-edit-modal">
    <div class="base-modal" style="width: 500px; max-width: 95%;">
        <div class="modal-title">Edit Line</div>
        
        <div class="input-group">
            <div class="label-row2"><label>Lyric Text</label></div>
            <textarea id="single-line-text" style="height: 80px; font-size: 1rem;"></textarea>
        </div>

        <div class="input-group" style="margin-top: 15px;">
            <div class="label-row2"><label>Start Time</label></div>
            <div class="offset-grid" style="margin-bottom: 0;">
                <div class="offset-col">
                    <label>Min</label>
                    <input type="number" id="edit-line-min" placeholder="00">
                </div>
                <div class="offset-col">
                    <label>Sec</label>
                    <input type="number" id="edit-line-sec" placeholder="00">
                </div>
                <div class="offset-col">
                    <label>Ms</label>
                    <input type="number" id="edit-line-ms" placeholder="00">
                </div>
            </div>
        </div>
        
        <div class="input-group" style="margin-top: 15px; display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="edit-line-bg" style="width: auto; height: 18px; width: 18px;">
            <label for="edit-line-bg" style="margin: 0; cursor: pointer; color: var(--text-main);">Background Vocal (Pro Mode)</label>
        </div>

        <div style="display: flex; gap: 8px; margin-top: 20px; flex-wrap: wrap;">
             <button class="btn btn-secondary" style="flex: 1; background: var(--danger);" onclick="deleteLineFromModal()">Remove Line</button>
             <button class="btn btn-secondary" style="flex: 1;" onclick="addLineFromModal()">+ Add Below</button>
        </div>
        <hr style="border: 0; margin: 15px 0;">
        <div style="display: flex; gap: 8px;">
            <button class="btn btn-secondary" style="flex: 1;" onclick="closeSingleLineEditModal()">Cancel</button>
            <button class="btn" style="flex: 1;" onclick="applySingleLineChanges()">Apply Changes</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="view-modal">
    <div class="base-modal" style="width: 300px; text-align: center;">
        <div class="modal-title">Select Editor View</div>
        <p style="color:var(--text-muted); font-size:0.9rem; margin-bottom:20px;">
            Choose which lines to display and sync.
        </p>
        <div style="display:flex; flex-direction:column; gap:10px;">
            <button id="view-btn-all" class="btn view-btn active" onclick="setViewMode('all')">All (Default)</button>
            <button id="view-btn-main" class="btn btn-outline view-btn" onclick="setViewMode('main')">Main</button>
            <button id="view-btn-bg" class="btn btn-secondary view-btn" onclick="setViewMode('bg')">Background</button>
        </div>
        <div style="margin-top:20px;">
            <button class="btn btn-secondary" onclick="document.getElementById('view-modal').classList.remove('active')">Cancel</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="export-modal">
    <div class="base-modal" style="width: 450px;">
        <div class="modal-title">Export Project</div>
        
        <label>LRC Preview</label>
        <textarea id="export-modal-preview" class="export-preview" readonly></textarea>
        
        <button class="btn btn-secondary" onclick="copyFromExportModal()" style="margin-bottom: 20px;">
            üìã Copy to Clipboard
        </button>

        <div class="label-row2"><label>Save To File</label></div>
        <div class="export-grid">
            <button class="btn" onclick="downloadLRC()">
                <span>üìÑ</span> .LRC
            </button>
            <button class="btn btn-outline" onclick="saveProject()">
                <span>‚ö°</span> .VXN (Project)
            </button>
        </div>

        <button class="btn btn-secondary" onclick="document.getElementById('export-modal').classList.remove('active')" style="margin-top: 20px;">
            Close
        </button>
    </div>
</div>
<script>
    // --- State ---
let state = {
    lyrics: [],
    mode: 'word',         // Default: Word
    currentIndex: 0,
    currentWordIndex: 0,
    isPlaying: false,
    isEditMode: false,
    isPreviewMode: false,
    currentSpeed: 1.0,
    syncInputMode: 'hybrid', // Default: Hybrid (Auto)
    glowMode: 'auto',      
    lrcFormat: 'pro',      // Default: Pro
    viewMode: 'all' 
};

    let currentFileName = "lyrics"; 
    let isDraggingSlider = false;
    let currentModalType = ''; 
    let editingLineIndex = -1; // Tracks which line is open in the modal

    // --- DOM Elements ---
    const appContainer = document.getElementById('app-container');
    const audioPlayer = document.getElementById('audio-player');
    const lyricsContainer = document.getElementById('lyrics-container');
    const timeDisplay = document.getElementById('time-display');
    const exportOutput = document.getElementById('export-output');
    const rawLyricsInput = document.getElementById('raw-lyrics');
    const offsetInput = document.getElementById('offset-val');
    const sidebar = document.getElementById('sidebar');
    const playBtn = document.getElementById('play-pause-btn');
    
    // Popups
    const speedBtn = document.getElementById('speed-btn');
    const speedPopup = document.getElementById('speed-popup');
    const volumePopup = document.getElementById('volume-popup');
    const volumeSlider = document.getElementById('volume-slider');
    const glowPopup = document.getElementById('glow-popup');
    const glowTrigger = document.getElementById('glow-trigger');
    
    // Modals
    const offsetModal = document.getElementById('offset-modal');
    const expandModal = document.getElementById('expand-modal');
    const expandTextarea = document.getElementById('expand-textarea');
    const expandTitle = document.getElementById('expand-modal-title');
    const expandActions = document.getElementById('expand-modal-actions');
    const syncSettingsModal = document.getElementById('sync-settings-modal');

    const wordContextUI = document.getElementById('word-context-ui');
    const ctxPrev = document.getElementById('ctx-prev-word');
    const ctxNext = document.getElementById('ctx-next-word');
    const editToggle = document.getElementById('edit-mode-toggle');
    const editToggleMobile = document.getElementById('edit-mode-toggle-mobile');
    const editToggleText = editToggle.querySelector('.btn-text');
    const previewBtn = document.getElementById('preview-btn');
    const mobilePreviewBtn = document.getElementById('mobile-preview-btn');
    
    const seekSlider = document.getElementById('seek-slider');
    const currTimeLbl = document.getElementById('curr-time-lbl');
    const durTimeLbl = document.getElementById('dur-time-lbl');
    
    // Indicators
    const mainSyncBtnText = document.getElementById('main-sync-btn-text');
    const mobileModeIndicator = document.getElementById('mobile-mode-indicator');
    const controlDock = document.querySelector('.control-dock');
    const btn = document.getElementById("fullscreenBtn");


     // Fullscreen
      btn.addEventListener("click", () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
      btn.textContent = "‚õ∂";
    } else {
      document.exitFullscreen();
      btn.textContent = "‚õ∂";
    }
  });

    document.addEventListener("fullscreenchange", () => {
    btn.textContent = document.fullscreenElement
      ? "‚õ∂"
      : "‚õ∂";
  });
  
// =========================================
// 2. CORE LOGIC (MODEL)
// =========================================

    // Initialize a new editor from a raw text
    function initializeEditor() {
        const rawText = rawLyricsInput.value;
        if (!rawText.trim()) return alert("Please enter lyrics first.");
        
        toggleSettings(false);
        
        // --- FIX START: Force Default Sync Mode ---
        setSyncInputMode('auto');
        // --- FIX END ---

        state.mode = document.querySelector('input[name="mode"]:checked').value;
        state.currentIndex = 0;
        state.currentWordIndex = 0;
        state.isEditMode = false;
        state.isPreviewMode = false;
        
        resetEditUI();

        const lines = rawText.split('\n').map(l => l.trim()).filter(l => l);
        state.lyrics = lines.map(lineText => {
            return { text: lineText, time: null, words: parseWords(lineText) };
        });

        renderEditor();
        updateWordContextUI();
    }


    // --- UI/UX Helpers ---
    function toggleSettings(show) {
        if(show) sidebar.classList.add('active');
        else sidebar.classList.remove('active');
    }

    function toggleEditMode() {
    if(state.isPreviewMode) togglePreviewMode(); 
    state.isEditMode = !state.isEditMode;
    
    if (state.isEditMode) {
        editToggle.classList.add('active');
        if(editToggleMobile) editToggleMobile.classList.add('active');
        editToggleText.textContent = "Done";
        appContainer.classList.add('is-editing');
        wordContextUI.classList.remove('visible'); 
    } else {
        editToggle.classList.remove('active');
        if(editToggleMobile) editToggleMobile.classList.remove('active');
        editToggleText.textContent = "Edit";
        appContainer.classList.remove('is-editing');
    }
    
    // Re-render to ensure buttons appear/disappear correctly and states update
    renderEditor(); 
    if(!state.isEditMode) updateVisuals();
    }
    
  function togglePreviewMode() {
    if (state.isEditMode) toggleEditMode(); // disable edit if previewing
    
    state.isPreviewMode = !state.isPreviewMode;

    // Buttons to toggle
    const buttons = [
        'btn-top-view',
        'edit-mode-toggle',
        'btn-top-offset',
        'btn-add-top',
        'edit-mode-toggle-mobile',
        'edit-offset-btn',
        'main-sync-btn-mobile'
    ].map(id => document.getElementById(id)).filter(Boolean); // skip nulls

    // Toggle preview classes
    [previewBtn, mobilePreviewBtn].forEach(btn => btn.classList.toggle('active', state.isPreviewMode));
    appContainer.classList.toggle('is-preview', state.isPreviewMode);
    
    // Hide word context in preview
    wordContextUI.classList.toggle('visible', !state.isPreviewMode);

    // Enable/disable buttons
    buttons.forEach(btn => btn.disabled = state.isPreviewMode);

    // Handle preview loop or visuals
    if (state.isPreviewMode) {
        cleanupGlowEffects();
        requestAnimationFrame(animatePreviewFrame);
    } else {
        cleanupGlowEffects();
        updateVisuals();
    }
}

    
    // --- GLOW SPEED LOGIC (UPDATED) ---
    function toggleGlowMenu() {
        glowPopup.classList.toggle('active');
    }

    function setGlowSpeed(val, isCustomInput = false) {
        val = parseFloat(val);
        if(isNaN(val)) return;

        document.documentElement.style.setProperty('--glow-speed', val + 's');
        
        if (isCustomInput) {
             glowTrigger.textContent = "Custom ‚ñº";
        } else {
            glowTrigger.textContent = val + "s ‚ñº";
            // Hide custom input if preset selected
            document.getElementById('custom-glow-input').classList.remove('active');
        }
        
        glowPopup.classList.remove('active');
    }

    function toggleCustomGlowInput() {
        glowTrigger.textContent = "Custom ‚ñº";
        const input = document.getElementById('custom-glow-input');
        input.classList.add('active');
        input.focus();
        glowPopup.classList.remove('active');
    }
 
    function cleanupGlowEffects() {
        document.querySelectorAll('.word-span').forEach(el => {
            el.classList.remove('preview-glow');
            el.style.transition = ""; // reset inline styles
        });
    }

    // --- Popups (Speed & Volume) ---
    function toggleSpeedMenu() {
        speedPopup.classList.toggle('active');
        volumePopup.classList.remove('active');
    }

    function toggleVolumeMenu() {
        volumePopup.classList.toggle('active');
        speedPopup.classList.remove('active');
    }

    function updateVolume(val) {
        audioPlayer.volume = val;
        updateRangeFill(volumeSlider);
    }

    function setSpeed(val) {
        state.currentSpeed = val;
        audioPlayer.playbackRate = val;
        speedBtn.textContent = val + "x";
        
        document.querySelectorAll('.speed-option').forEach(btn => {
            btn.classList.remove('selected');
            if(parseFloat(btn.innerText) === val) btn.classList.add('selected');
        });
        speedPopup.classList.remove('active');
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.popup-wrapper')) {
            speedPopup.classList.remove('active');
            volumePopup.classList.remove('active');
            glowPopup.classList.remove('active');
        }
    });

    // --- File Input ---
    document.getElementById('audio-file').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        audioPlayer.src = URL.createObjectURL(file);
        currentFileName = file.name.replace(/\.[^/.]+$/, "");
        document.getElementById('audio-file-label').innerHTML = `<span>üéµ ${file.name}</span>`;
        
        // Enable Tabs
        setWorkflowDisabled(false);

        // FIX: Re-render the editor to unlock the "Open LRC" button in the Welcome Screen
        renderEditor();
    }
});

    // --- Slider Fill ---
    function updateRangeFill(slider) {
        const min = slider.min || 0;
        const max = slider.max || 100;
        const val = slider.value;
        const percent = (val - min) * 100 / (max - min);
        slider.style.background = `linear-gradient(to right, var(--primary) 0%, var(--primary) ${percent}%, var(--bg-input) ${percent}%, var(--bg-input) 100%)`;
    }
    updateRangeFill(volumeSlider);

    // --- Playback Slider ---
    audioPlayer.addEventListener('loadedmetadata', () => {
        seekSlider.max = audioPlayer.duration;
        durTimeLbl.textContent = formatSimpleTime(audioPlayer.duration);
        updateRangeFill(seekSlider);
    });

    audioPlayer.addEventListener('timeupdate', () => {
        if (!isDraggingSlider) {
            seekSlider.value = audioPlayer.currentTime;
            currTimeLbl.textContent = formatSimpleTime(audioPlayer.currentTime);
            updateRangeFill(seekSlider);
        }
    });

   // --- UPDATED PREVIEW ANIMATION LOOP ---
function animatePreviewFrame() {
    if (!state.isPreviewMode) return;
    
    if(state.lyrics.length > 0) {
        const curTime = audioPlayer.currentTime;
        
        // --- 1. Identify Active MAIN Line ---
        let activeMainIdx = -1;
        for(let i = 0; i < state.lyrics.length; i++) {
            const l = state.lyrics[i];
            if (l.time !== null && l.time <= curTime && !l.isBg) {
                activeMainIdx = i;
            } else if (l.time !== null && l.time > curTime && !l.isBg) {
                break;
            }
        }

        // Update Main Line Focus
        if(activeMainIdx !== -1 && activeMainIdx !== state.currentIndex) {
            state.currentIndex = activeMainIdx;
            state.currentWordIndex = 0; 
            updateVisuals(); 
            scrollToActive();
        }

        // --- 2. Render & Cleanup logic for Rewind/Forward ---
        state.lyrics.forEach((l, idx) => {
            const row = document.getElementById(`line-${idx}`);
            if(!row) return;

            // BACKGROUND VOCALS
            if (l.isBg) {
                const endTime = getLineEndTime(idx);
                const isActive = (curTime >= l.time && curTime < endTime);
                
                if (isActive) {
                    row.classList.add('active-bg-preview');
                    animateWordGlow(idx, curTime);
                } else {
                    row.classList.remove('active-bg-preview');
                    // FIX: Only clean up if we rewound before the start time.
                    // Otherwise, leave it alone (preserve history).
                    if (l.time !== null && curTime < l.time) {
                        cleanupLineGlow(idx);
                    }
                }
            } 
            // MAIN LINES
            else {
                if (idx === activeMainIdx) {
                    // Currently active: Update words
                    animateWordGlow(idx, curTime);
                } 
                else if (idx > activeMainIdx) {
                    // Future lines (Rewind scenario): Clean up glow
                    cleanupLineGlow(idx);
                }
                // Lines < activeMainIdx are "past". We leave them intact.
            }
        });
    }

    requestAnimationFrame(animatePreviewFrame);
}

    seekSlider.addEventListener('input', () => {
        isDraggingSlider = true;
        currTimeLbl.textContent = formatSimpleTime(seekSlider.value);
        updateRangeFill(seekSlider);
    });

    seekSlider.addEventListener('change', () => {
        audioPlayer.currentTime = seekSlider.value;
        isDraggingSlider = false;
        if(audioPlayer.paused) timeDisplay.textContent = formatTimeDisplay(audioPlayer.currentTime);
        updateRangeFill(seekSlider);
        // REMOVED: cleanupGlowEffects(); -> Rely on animatePreviewFrame to correct state
    });

    function formatSimpleTime(s) {
        if(!s || isNaN(s)) return "0:00";
        const m = Math.floor(s / 60);
        const sec = Math.floor(s % 60).toString().padStart(2, '0');
        return `${m}:${sec}`;
    }

    // --- Playback ---doc
    function togglePlay() {
        if (audioPlayer.paused) audioPlayer.play();
        else audioPlayer.pause();
    }

    function seekAudio(seconds) {
        audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime + seconds);
        if(audioPlayer.paused) timeDisplay.textContent = formatTimeDisplay(audioPlayer.currentTime);
        updateRangeFill(seekSlider);
    }

    audioPlayer.addEventListener('play', () => {
        state.isPlaying = true;
        playBtn.textContent = "ùóúùóú";
        requestAnimationFrame(updateTimer);
    });

    audioPlayer.addEventListener('pause', () => {
        state.isPlaying = false;
        playBtn.textContent = "‚ñ∂";
        timeDisplay.textContent = formatTimeDisplay(audioPlayer.currentTime);
    });

    function updateTimer() {
        if (!audioPlayer.paused) {
            timeDisplay.textContent = formatTimeDisplay(audioPlayer.currentTime);
            requestAnimationFrame(updateTimer);
        }
    }

    function resetEditUI() {
        editToggle.classList.remove('active');
        if(editToggleMobile) editToggleMobile.classList.remove('active');
        editToggleText.textContent = "Edit Text";
        appContainer.classList.remove('is-editing');
        appContainer.classList.remove('is-preview');
        previewBtn.classList.remove('active');
        mobilePreviewBtn.classList.remove('active');
    }

    function parseWords(text) {
    // 1. Replace dash with "dash space" to force a split but keep the character
    // 2. Split by whitespace
    // 3. Filter empty strings
    return text.replace(/-/g, '- ').split(/\s+/)
        .filter(w => w)
        .map(w => ({ text: w, start: null, end: null }));
}

    // --- Project Saving / Loading ---
    function saveProject() {
        const projectData = {
            version: "v4",
            timestamp: Date.now(),
            mode: state.mode,
            lyrics: state.lyrics,
            currentIndex: state.currentIndex
        };
        const blob = new Blob([JSON.stringify(projectData, null, 2)], {type: 'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${currentFileName}.vxn`; 
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

   function loadProject(input) {
    const file = input.files[0];
    if(!file) return;
    
    // 1. Force Stop Preview if active
    if (state.isPreviewMode) {
        togglePreviewMode();
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            state.lyrics = data.lyrics;
            state.mode = data.mode;
            state.currentIndex = 0; 
            state.currentWordIndex = 0;
            
            if(state.mode === 'line') document.getElementById('mode-line').checked = true;
            else document.getElementById('mode-word').checked = true;

            // ENABLE TABS (Updated Logic)
            setWorkflowDisabled(false);

            toggleSettings(false);
            resetEditUI();
            renderEditor();
            updateVisuals();
            alert("Project loaded!");
        } catch(err) {
            alert("Error loading project file: " + err);
        }
    };
    reader.readAsText(file);
    input.value = "";
}

    // --- EXPANDABLE MODAL LOGIC ---
    function openExpandModal(type) {
        currentModalType = type;
        expandModal.classList.add('active');
        expandActions.innerHTML = ''; 

        if (type === 'raw') {
            expandTitle.textContent = "Edit Raw Lyrics";
            expandTextarea.value = rawLyricsInput.value;
            expandTextarea.placeholder = "Line 1...\nLine 2...";
            
            // Symbol Button
            const btnSymbol = document.createElement('button');
            btnSymbol.className = 'btn btn-secondary btn-note';
            btnSymbol.style.flex = "0 0 auto";
            btnSymbol.textContent = "‚ô©";
            btnSymbol.onclick = () => {
                const startPos = expandTextarea.selectionStart;
                const endPos = expandTextarea.selectionEnd;
                const text = expandTextarea.value;
                expandTextarea.value = text.substring(0, startPos) + "‚ô©" + text.substring(endPos);
                expandTextarea.focus();
                expandTextarea.selectionStart = expandTextarea.selectionEnd = startPos + 1;
            };

            const btnSave = document.createElement('button');
            btnSave.className = 'btn';
            btnSave.textContent = "Update Input";
            btnSave.onclick = () => {
                rawLyricsInput.value = expandTextarea.value;
                closeExpandModal();
            };
            
            expandActions.appendChild(btnSymbol);
            expandActions.appendChild(btnSave);
        } 
        else if (type === 'lrc') {
            expandTitle.textContent = "Edit / Import LRC";
            if(exportOutput.value.trim()) expandTextarea.value = exportOutput.value;
            else { generateLRC(); expandTextarea.value = exportOutput.value; }
            expandTextarea.placeholder = "[00:12.50]Paste your LRC content here to import...";

            // --- FILE INPUT HANDLER ---
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.lrc,.txt';
            fileInput.style.display = 'none';
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (ev) => {
                    expandTextarea.value = ev.target.result;
                    // Highlight that content was loaded
                    expandTextarea.style.borderColor = 'var(--secondary)';
                    setTimeout(() => expandTextarea.style.borderColor = 'rgba(255,255,255,0.1)', 500);
                };
                reader.readAsText(file);
            };
            expandActions.appendChild(fileInput);

            // Button 1: Open File
            const btnOpen = document.createElement('button');
            btnOpen.className = 'btn btn-outline';
            btnOpen.innerHTML = "üìÇ Open File";
            btnOpen.title = "Load from .lrc file";
            btnOpen.onclick = () => fileInput.click();

            // Button 2: Import Text (Parse whatever is in the box)
            const btnImport = document.createElement('button');
            btnImport.className = 'btn';
            btnImport.innerHTML = "Import Text";
            btnImport.onclick = () => {
                parseAndLoadLRC(expandTextarea.value);
                closeExpandModal();
            };
            
            expandActions.appendChild(btnOpen);
            expandActions.appendChild(btnImport);
        }
    }

    function closeExpandModal() { expandModal.classList.remove('active'); }
    
    // Copy/Load Buttons in Sidebar
    function copyLRC() {
        exportOutput.select();
        document.execCommand('copy');
        alert("LRC copied to clipboard!");
    }
    
    function loadLRCFromSidebar() {
        parseAndLoadLRC(exportOutput.value);
    }

    function parseAndLoadLRC(lrcText) {
        if (state.isPreviewMode) {
            togglePreviewMode();
        }
        if (!lrcText.trim()) return;

        const lines = lrcText.split('\n');
        const newLyrics = [];
        
        // Regex Definitions
        const standardTimeRegex = /\[(\d{2}):(\d{2}(?:\.\d+)?)\](.*)/;
        const proLineRegex = /^\[(\d{2}):(\d{2}(?:\.\d+)?)\]<(\d{2}):(\d{2}(?:\.\d+)?)>(.*)/;
        const bgTagRegex = /\[bg:(.*?)\]/; 
        // FIX: Regex to detect Advanced Format word data lines (e.g., <Word:0:0|Word:0:0>)
        const advancedWordDataRegex = /^<(.+:.+:.+)>/; 

        let hasWordData = false;
        let detectedFormat = 'advanced'; 

        lines.forEach(line => {
            const trimmed = line.trim();
            if(!trimmed) return;

            // --- 1. Extract Background Vocals (if any) ---
            let bgContent = null;
            let mainContent = trimmed;

            const bgMatch = trimmed.match(bgTagRegex);
            if (bgMatch) {
                bgContent = bgMatch[1]; 
                mainContent = trimmed.replace(bgTagRegex, '').trim();
            }

            // --- 2. Process Main Line ---
            if (mainContent) {
                const proMatch = mainContent.match(proLineRegex);
                const advWordMatch = mainContent.match(advancedWordDataRegex); // Check for advanced data line
                
                if (proMatch) {
                    // --- Case A: Pro Mode Line ---
                    detectedFormat = 'pro'; 
                    hasWordData = true;
                    
                    const lineMin = parseInt(proMatch[1]);
                    const lineSec = parseFloat(proMatch[2]);
                    const lineTime = (lineMin * 60) + lineSec;
                    
                    const rawContent = mainContent.replace(/^\[.*?\]/, ''); 
                    const words = parseProWords(rawContent); 
                    
                    // Reconstruct text
                    const reconstructedText = words.map((w, i) => {
                        if (i === words.length - 1 || w.text.endsWith('-')) return w.text;
                        return w.text + " ";
                    }).join('');

                    newLyrics.push({ 
                        text: reconstructedText, 
                        time: lineTime, 
                        words: words, 
                        isBg: false 
                    });
                } 
                else if (advWordMatch && newLyrics.length > 0) {
                    // --- Case B: Advanced Mode Word Data Line ---
                    // This line contains word timings for the PREVIOUSLY added line.
                    // Format: <Word:Start:End|Word:Start:End>
                    
                    const rawData = advWordMatch[1];
                    const wordParts = rawData.split('|');
                    const lastLine = newLyrics[newLyrics.length - 1]; // Get the previous line
                    
                    if (lastLine && !lastLine.isBg) { // Only attach to main lines usually
                        const newWords = wordParts.map(part => {
                            // Extract parts backwards to handle colons in text safely
                            const lastColon = part.lastIndexOf(':');
                            const secondLastColon = part.lastIndexOf(':', lastColon - 1);
                            
                            if (lastColon === -1 || secondLastColon === -1) return null;
                            
                            const wText = part.substring(0, secondLastColon);
                            const wStart = part.substring(secondLastColon + 1, lastColon);
                            const wEnd = part.substring(lastColon + 1);

                            return {
                                text: wText,
                                start: wStart ? parseFloat(wStart) : null,
                                end: wEnd ? parseFloat(wEnd) : null
                            };
                        }).filter(w => w);

                        if (newWords.length > 0) {
                            lastLine.words = newWords;
                            hasWordData = true; // FIX: Correctly flag that we have word data
                        }
                    }
                }
                else {
                    // --- Case C: Standard Timestamped Line (or just text) ---
                    const timeMatch = mainContent.match(standardTimeRegex);
                    if (timeMatch) {
                        const min = parseInt(timeMatch[1]);
                        const sec = parseFloat(timeMatch[2]);
                        const text = timeMatch[3].trim();
                        const totalTime = (min * 60) + sec;
                        newLyrics.push({ 
                            text: text, 
                            time: totalTime, 
                            words: parseWords(text), 
                            isBg: false 
                        });
                    } else if (!mainContent.startsWith('[') && !mainContent.startsWith('<')) {
                        // Plain text fallback
                         newLyrics.push({ 
                             text: mainContent, 
                             time: null, 
                             words: parseWords(mainContent), 
                             isBg: false 
                         });
                    }
                }
            }

            // --- 3. Process Background Vocal Line (if detected earlier) ---
            if (bgContent) {
                const words = parseProWords(bgContent);
                const reconstructedBgText = words.map((w, i) => {
                    if (i === words.length - 1 || w.text.endsWith('-')) return w.text;
                    return w.text + " ";
                }).join('');

                let startTime = null;
                if(words.length > 0 && words[0].start !== null) {
                    startTime = words[0].start;
                }

                newLyrics.push({ 
                    text: reconstructedBgText, 
                    time: startTime, 
                    words: words, 
                    isBg: true 
                });
            }
        });

        if (newLyrics.length === 0) { alert("No valid LRC timestamps found."); return; }
        
        state.lyrics = newLyrics;
        state.currentIndex = 0;
        state.currentWordIndex = 0;

        // Apply Detected Settings
        if (detectedFormat === 'pro') {
            setLRCFormat('pro');
        } else {
            setLRCFormat('advanced');
            // FIX: This will now correctly evaluate to true because of Case B
            state.mode = hasWordData ? 'word' : 'line'; 
            document.getElementById(hasWordData ? 'mode-word' : 'mode-line').checked = true;
        }

        toggleSettings(false);
        resetEditUI();
        renderEditor();
        updateVisuals();
        
        rawLyricsInput.value = newLyrics.map(l => l.text).join('\n');
        exportOutput.value = lrcText;
        
        alert(`Imported ${newLyrics.length} lines.`);
    }
    
    // --- Rendering ---
    function renderEditor() {
        lyricsContainer.innerHTML = '';

        // 1. Show Welcome Screen if empty
        if (state.lyrics.length === 0) {
            const isAudioLoaded = !!audioPlayer.src;
            
            const welcomeDiv = document.createElement('div');
            welcomeDiv.className = 'welcome-container';
            welcomeDiv.innerHTML = `
                <div class="welcome-title">‚ö° Welcome to Voxen</div>
                <div class="welcome-actions">
                    <button class="welcome-btn" onclick="document.getElementById('audio-file').click()">
                        <span>üéµ</span> Select Song
                    </button>
                    <button class="welcome-btn" id="welcome-lrc-btn" onclick="openExpandModal('lrc')">
                        <span>üìÇ</span> Open LRC
                    </button>
                    <button class="welcome-btn" onclick="initializeEmptyEditor()">
                         <span>üìù</span> Add Line
                    </button>
                    <button class="welcome-btn" onclick="window.open('https://github.com/Raqhael-ux/Voxen-LRC-Editor', '_blank')">
                         <span>üîó</span> Github
                    </button>
                    <button class="welcome-btn" style="min-width: 20px; padding: 0 20px;" onclick="window.open('https://github.com/Raqhael-ux/Voxen-LRC-Editor', '_blank')">
                         <span>?</span>
                    </button>
                </div>
                <div style="margin-top: 20px; font-size: 0.8rem; color: var(--text-muted); opacity: 0.5;">
                    <p>Load an audio file to enable LRC features.</p>
                    <a href="#" style="color: inherit; text-decoration: underline;">v8.1.1</a>
                </div>
            `;
            
            lyricsContainer.appendChild(welcomeDiv);

            // Safer check for the button after appending
            setTimeout(() => {
                const lrcBtn = document.getElementById('welcome-lrc-btn');
                if(lrcBtn && !isAudioLoaded) {
                    lrcBtn.disabled = true;
                    lrcBtn.title = "Please upload audio first";
                }
            }, 0);
            return;
        }

        // 2. Render Lines
        state.lyrics.forEach((item, index) => {
            const row = document.createElement('div');
            row.className = `lyric-line ${index === state.currentIndex && !state.isEditMode ? 'active' : ''} ${item.isBg ? 'is-bg-vocal' : ''}`;
            row.id = `line-${index}`;

            const meta = document.createElement('div');
            meta.className = 'line-meta';
            
            // --- NEW TIMESTAMP GROUP ---
            const tsGroup = document.createElement('div');
            tsGroup.className = 'timestamp-group';
            
            // Calc time values
            let tMin = "", tSec = "", tMs = "";
            if (item.time !== null) {
                tMin = Math.floor(item.time / 60).toString().padStart(2, '0');
                const rem = item.time % 60;
                tSec = Math.floor(rem).toString().padStart(2, '0');
                tMs = Math.round((rem - Math.floor(rem)) * 100).toString().padStart(2, '0');
            }

            // Create Inputs Helper
            const createTsInput = (val, max, type) => {
                const inp = document.createElement('input');
                inp.className = 'ts-digit';
                inp.value = val;
                inp.placeholder = "00";
                
                // Save on change
                inp.onchange = (e) => {
                   let val = parseInt(e.target.value) || 0;
                   if(val < 0) val = 0;
                   if(type !== 'min' && val > max) val = max; // clamp seconds/ms
                   
                   // Re-calculate total time
                   const currentMin = parseInt(tsGroup.children[0].value) || 0;
                   const currentSec = parseInt(tsGroup.children[2].value) || 0;
                   const currentMs  = parseInt(tsGroup.children[4].value) || 0;
                   
                   const newTotal = (currentMin * 60) + currentSec + (currentMs / 100);
                   item.time = newTotal;
                   
                   // Update visual padding
                   e.target.value = val.toString().padStart(2, '0');
                   generateLRC();
                };
                
                // Prevent editing in preview
                if(state.isPreviewMode) inp.readOnly = true;
                
                return inp;
            };

            const inpMin = createTsInput(tMin, 999, 'min');
            const inpSec = createTsInput(tSec, 59, 'sec');
            const inpMs = createTsInput(tMs, 99, 'ms');

            tsGroup.appendChild(inpMin);
            tsGroup.appendChild(makeSep(':'));
            tsGroup.appendChild(inpSec);
            tsGroup.appendChild(makeSep('.'));
            tsGroup.appendChild(inpMs);
            
            meta.appendChild(tsGroup);
            row.appendChild(meta);

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'line-content-wrapper';
            const content = document.createElement('div');
            content.className = 'line-text';
            content.contentEditable = "false"; 

            if (state.mode === 'line') {
                 content.innerText = item.text;
            } else {
                item.words.forEach((word, wIdx) => {
                    const span = document.createElement('span');
                    span.className = 'word-span';
                    span.textContent = word.text;
                    span.id = `word-${index}-${wIdx}`;
                    if(word.start !== null) span.classList.add('synced');
                    
                    span.onclick = (e) => {
                        e.stopPropagation();
                        if(state.isPreviewMode || state.isEditMode) return; 
                        state.currentIndex = index;
                        state.currentWordIndex = wIdx;
                        updateVisuals();
                    };
                    content.appendChild(span);
                    content.appendChild(document.createTextNode(" "));
                });
            }
            
            content.onclick = (e) => {
                if(e.target === content) {
                     if(state.isPreviewMode || state.isEditMode) return;
                    state.currentIndex = index;
                    if(state.mode === 'word') state.currentWordIndex = 0;
                    updateVisuals();
                }
            };

            contentWrapper.appendChild(content);
            row.appendChild(contentWrapper);

            // --- CHANGED: Action Buttons (Delete + Edit) ---
            const actions = document.createElement('div');
            actions.className = 'line-actions';
            
            // Delete Button
            const btnDel = document.createElement('button');
            btnDel.className = 'action-btn btn-delete'; 
            btnDel.innerHTML = '‚úï'; 
            btnDel.title = "Delete Line";
            btnDel.style.marginRight = "4px";
            btnDel.onclick = (e) => { 
                e.stopPropagation(); 
                if(confirm('Delete this line?')) deleteLine(index); 
            };
            
            // Edit Button
            const btnEdit = document.createElement('button');
            btnEdit.className = 'action-btn'; 
            btnEdit.innerHTML = '‚úé'; 
            btnEdit.title = "Edit Text";
            btnEdit.onclick = (e) => { e.stopPropagation(); openSingleLineEditModal(index); };
            
            actions.appendChild(btnDel);
            actions.appendChild(btnEdit);
            row.appendChild(actions);

            lyricsContainer.appendChild(row);
        });

       // 3. Append "Add New Line" Button
        const addBtn = document.createElement('div');
        addBtn.className = 'lyric-line add-new-line-btn';
        addBtn.innerHTML = '+ Add New Line';
        addBtn.onclick = () => {
            if (state.isPreviewMode) return; 

            // FIX: Auto-detect View Mode for new line type
            const isBgMode = (state.viewMode === 'bg');
            
            // Create new line with correct isBg property
            const newItem = { 
                text: "New Line", 
                time: null, 
                words: parseWords("New Line"),
                isBg: isBgMode // true if in BG view, false otherwise
            };
            
            state.lyrics.push(newItem);
            renderEditor();
            setTimeout(() => { lyricsContainer.scrollTop = lyricsContainer.scrollHeight; }, 100);
        };
        lyricsContainer.appendChild(addBtn);
    }

    function addLineAtTop() {
        const newItem = { text: "New Line", time: null, words: parseWords("New Line") };
        state.lyrics.unshift(newItem); state.currentIndex++; renderEditor();
    }
    function addLine(index) {
        const newItem = { text: "New Line", time: null, words: parseWords("New Line") };
        state.lyrics.splice(index + 1, 0, newItem); renderEditor();
    }
    function deleteLine(index) {
        state.lyrics.splice(index, 1);
        if(state.currentIndex >= state.lyrics.length) state.currentIndex = Math.max(0, state.lyrics.length - 1);
        renderEditor();
    }

    // --- SYNC LOGIC (TAP & HOLD) ---
    // Attaching Listeners
    const syncBtnDesktop = document.getElementById('main-sync-btn');
    const syncBtnMobile = document.getElementById('main-sync-btn-mobile');

    [syncBtnDesktop, syncBtnMobile].forEach(btn => {
        if(!btn) return;
        btn.addEventListener('mousedown', (e) => handleSyncDown(e));
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); handleSyncDown(e); });
        
        btn.addEventListener('mouseup', (e) => handleSyncUp(e));
        btn.addEventListener('touchend', (e) => { e.preventDefault(); handleSyncUp(e); });
        btn.addEventListener('mouseleave', (e) => handleSyncUp(e)); // Safety
    });

    function updateAutoModeLabel() {
    // Only run this logic if we are actually in Auto mode
    if (state.syncInputMode !== 'auto') return;
    
    // Safety check
    if (!state.lyrics[state.currentIndex]) return;

    const currentLine = state.lyrics[state.currentIndex];
    
    // Logic: If it's the last word of the line, Auto mode behaves like HOLD.
    // Otherwise, it behaves like TAP.
    const isLastWord = state.currentWordIndex === currentLine.words.length - 1;

    if (isLastWord) {
        mainSyncBtnText.textContent = "HOLD";
        mobileModeIndicator.textContent = "Hold";
    } else {
        mainSyncBtnText.textContent = "TAP";
        mobileModeIndicator.textContent = "Tap";
    }
}

    let holdActive = false;

   function handleSyncDown(e) {
    if (state.currentIndex >= state.lyrics.length) return;
    if(state.lyrics.length === 0 || state.isEditMode || state.isPreviewMode) return;
    
    if (holdActive) return;

    // Visuals: Button press
    const btns = [syncBtnDesktop, syncBtnMobile];
    btns.forEach(b => b.classList.add('holding'));

    const offset = parseInt(offsetInput.value) || 0;
    const time = Math.max(0, audioPlayer.currentTime + (offset / 1000));

    if (state.mode === 'line') {
        syncLine(state.currentIndex, time);
        state.currentIndex = getNextValidLineIndex(state.currentIndex + 1);
        scrollToActive();
        updateVisuals();
    } else {
        // --- WORD MODE LOGIC ---
        
        if (state.syncInputMode === 'tap') {
            // Standard Tap
            syncWordTap(state.currentIndex, state.currentWordIndex, time);
            scrollToActive();
            updateVisuals();

        } else if (state.syncInputMode === 'hold') {
            // Standard Hold
            startHoldAction(time);

        } else if (state.syncInputMode === 'auto') {
            // --- Task 1: Auto Mode Logic ---
            const currentLine = state.lyrics[state.currentIndex];
            const isLastWord = state.currentWordIndex === currentLine.words.length - 1;

            if (isLastWord) {
                // Last word -> Behaves like Hold
                startHoldAction(time);
            } else {
                // Not last word -> Behaves like Tap
                syncWordTap(state.currentIndex, state.currentWordIndex, time);
                scrollToActive();
                updateVisuals();
            }
        }
    }
}

// Helper to centralize Hold starting logic (used by Hold and Auto)
function startHoldAction(time) {
    holdActive = true;
    
    // Task 3: Activate Dock Glow
    controlDock.classList.add('active-hold-glow');
    
    syncWordStart(state.currentIndex, state.currentWordIndex, time);
    scrollToActive();
    updateVisuals();
}

 function handleSyncUp(e) {
    // Visuals: Button release
    const btns = [syncBtnDesktop, syncBtnMobile];
    btns.forEach(b => b.classList.remove('holding'));

    if (!holdActive) return; 
    holdActive = false;
    
    // Task 3: Deactivate Dock Glow
    controlDock.classList.remove('active-hold-glow');

    const offset = parseInt(offsetInput.value) || 0;
    const time = Math.max(0, audioPlayer.currentTime + (offset / 1000));

    // Logic for ending a Hold action (Applies to Hold mode AND Auto mode's last word)
    if (state.mode === 'word') {
         syncWordEnd(state.currentIndex, state.currentWordIndex, time);
         advanceWordCursor();
         scrollToActive();
         updateVisuals();
    }
}
    function syncLine(idx, time) {
        if(!state.lyrics[idx]) return;
        state.lyrics[idx].time = time;
        
        // Update the 3 inputs
        const row = document.getElementById(`line-${idx}`);
        if(row) {
            const group = row.querySelector('.timestamp-group');
            if(group) {
                const inputs = group.querySelectorAll('input');
                
                const m = Math.floor(time / 60);
                const s = Math.floor(time % 60);
                const ms = Math.round((time % 1) * 100);

                if(inputs[0]) inputs[0].value = m.toString().padStart(2,'0');
                if(inputs[1]) inputs[1].value = s.toString().padStart(2,'0');
                if(inputs[2]) inputs[2].value = ms.toString().padStart(2,'0');
            }
        }
        generateLRC();
    }
// Classic Tap: Sets start, auto sets prev end, advances
    function syncWordTap(lIdx, wIdx, time) {
        const line = state.lyrics[lIdx];
        if(!line) return;
        const word = line.words[wIdx];
        
        word.start = time;

        // --- PREVIOUS WORD LOGIC ---
        if(wIdx > 0) {
            // Case A: Previous word is in the SAME line.
            // In Auto/Tap modes, mid-line words always chain together.
            line.words[wIdx-1].end = time;
        }
        else if (lIdx > 0) {
            // Case B: Previous word is the LAST word of the PREVIOUS line.
            const prev = state.lyrics[lIdx-1];
            if(prev.words.length) {
                const prevWord = prev.words[prev.words.length-1];

                // BUG FIX:
                // In 'auto' mode, this previous word was a "Hold". 
                // If it already has an end time (from releasing the button), DO NOT overwrite it.
                if (state.syncInputMode === 'auto') {
                    if (prevWord.end === null) prevWord.end = time;
                } else {
                    // In strict 'tap' mode, we always overwrite to close the gap.
                    prevWord.end = time;
                }
            }
        }

        // Auto-close very last word of song if in Tap mode
        if (state.syncInputMode === 'tap' && lIdx === state.lyrics.length - 1 && wIdx === line.words.length - 1) {
             if(audioPlayer.duration) word.end = audioPlayer.duration;
        }

        if(wIdx === 0) syncLine(lIdx, time);
        advanceWordCursor();
        generateLRC();
    }

    // Hold Mode Start: Just set start
    function syncWordStart(lIdx, wIdx, time) {
        const line = state.lyrics[lIdx];
        if(!line) return;
        const word = line.words[wIdx];
        word.start = time;
        
        // FIX: In Auto Mode, the transition from the second-to-last word (Tap)
        // to the last word (Hold) requires closing the gap of the previous word.
        if (state.syncInputMode === 'auto' && wIdx > 0) {
             line.words[wIdx-1].end = time;
        }
        
        if(wIdx === 0) syncLine(lIdx, time);
        generateLRC(); // Save partial state
    }

    // Hold Mode End: Just set end
    function syncWordEnd(lIdx, wIdx, time) {
        const line = state.lyrics[lIdx];
        if(!line) return;
        const word = line.words[wIdx];
        word.end = time;
        generateLRC();
    }

    // Replace the existing advanceWordCursor function:

function advanceWordCursor() {
    const line = state.lyrics[state.currentIndex];
    if(!line) return;
    
    if(state.currentWordIndex < line.words.length - 1) {
        state.currentWordIndex++;
    } else {
        // End of line, find next VALID line based on View Mode
        const nextLineIdx = getNextValidLineIndex(state.currentIndex + 1);
        state.currentIndex = nextLineIdx;
        state.currentWordIndex = 0;
    }
}

    // --- Bulk Offset Logic ---
    function openOffsetModal() { offsetModal.classList.add('active'); }
    function closeOffsetModal() { 
        offsetModal.classList.remove('active'); 
        document.getElementById('off-min').value = 0;
        document.getElementById('off-sec').value = 0;
        document.getElementById('off-ms').value = 0;
    }
    function applyOffset() {
        const mins = parseInt(document.getElementById('off-min').value) || 0;
        const secs = parseInt(document.getElementById('off-sec').value) || 0;
        const ms = parseInt(document.getElementById('off-ms').value) || 0;
        const totalOffsetSeconds = (mins * 60) + secs + (ms / 1000);
        if (totalOffsetSeconds === 0) return closeOffsetModal();

        state.lyrics.forEach(line => {
            if(line.time !== null) line.time = Math.max(0, line.time + totalOffsetSeconds);
            if(line.words) {
                line.words.forEach(w => {
                    if(w.start !== null) w.start = Math.max(0, w.start + totalOffsetSeconds);
                    if(w.end !== null) w.end = Math.max(0, w.end + totalOffsetSeconds);
                });
            }
        });
        renderEditor(); updateVisuals(); generateLRC(); closeOffsetModal();
        alert(`Offset of ${totalOffsetSeconds}s applied.`);
    }

 // Update Sync Settings UI opener to handle the new button
function openSyncSettings() { 
    syncSettingsModal.classList.add('active');
    
    const holdBtn = document.getElementById('opt-hold');
    const autoBtn = document.getElementById('opt-sync-auto');
    const tapBtn = document.getElementById('opt-tap');

    // 1. Reset visual disabled state first
    holdBtn.classList.remove('disabled-mode');
    autoBtn.classList.remove('disabled-mode');
    tapBtn.classList.remove('disabled-mode');

    // 2. Logic Restrictions
    if (state.lrcFormat === 'pro') {
        // Pro Mode: Tap is disabled (doesn't support precise duration well)
        // Hybrid (Auto) and Hold are ENABLED
        tapBtn.classList.add('disabled-mode'); 
        
        // Ensure UI reflects the default state if needed
        if (state.syncInputMode === 'tap') {
            setSyncInputMode('auto');
        }
    } 
    else if (state.mode === 'line') {
        // Line Mode: Only Tap is allowed
        holdBtn.classList.add('disabled-mode');
        autoBtn.classList.add('disabled-mode');
    }
}
    
    function closeSyncSettings() { syncSettingsModal.classList.remove('active'); }

   // Update Sync Mode Setter
function setSyncInputMode(mode) {
    // Prevent setting restricted modes if line mode
    if ((mode === 'hold' || mode === 'auto') && state.mode === 'line') return;

    // For Pro Mode: Prevent 'tap', but allow 'hold' and 'auto'
    if (state.lrcFormat === 'pro' && mode === 'tap') return;

    state.syncInputMode = mode;
    
    document.getElementById('opt-tap').classList.toggle('active', mode === 'tap');
    document.getElementById('opt-hold').classList.toggle('active', mode === 'hold');
    document.getElementById('opt-sync-auto').classList.toggle('active', mode === 'auto');

    if (mode === 'hold' || mode === 'auto') {
        setGlowMode('auto');
    }
    
    updateSyncUI();
    updateWordContextUI(); 
}

    function setGlowMode(mode) {
        state.glowMode = mode;
        document.getElementById('opt-custom').classList.toggle('active', mode === 'custom');
        document.getElementById('opt-auto').classList.toggle('active', mode === 'auto');
        
        // Hide/Show Speed options
        const speedCont = document.getElementById('glow-speed-container');
        if(mode === 'auto') speedCont.classList.add('disabled');
        else speedCont.classList.remove('disabled');
    }

    // --- Scroll Logic ---
    function scrollToActive() {
        const el = document.getElementById(`line-${state.currentIndex}`);
        if(el) {
            // Check if Mobile
            if(window.innerWidth <= 900) {
                 const container = lyricsContainer;
                 const elTop = el.offsetTop; 
                 const targetPos = elTop - (container.clientHeight * 0.20);
                 
                 container.scrollTo({ top: targetPos, behavior: 'smooth' });
            } else {
                 // Desktop default center
                 el.scrollIntoView({ behavior: 'auto', block: 'center' });
            }
        }
    }

   function updateVisuals() {
        if(state.isEditMode) return;

        document.querySelectorAll('.word-span.active-word').forEach(el => el.classList.remove('active-word'));
        if (state.mode === 'word' && !state.isPreviewMode) {
             state.lyrics.forEach((l, lI) => l.words.forEach((w, wI) => {
                const span = document.getElementById(`word-${lI}-${wI}`);
                if(span) {
                    if(w.start !== null) span.classList.add('synced');
                    else span.classList.remove('synced');
                }
            }));
        }

        // Highlight Active Line
        document.querySelectorAll('.lyric-line').forEach((el, idx) => {
            if(idx === state.currentIndex) el.classList.add('active');
            else el.classList.remove('active');
        });

        if (state.currentIndex >= state.lyrics.length) {
            wordContextUI.classList.remove('visible');
            return;
        }

        // Highlight Active Word
        if (state.mode === 'word' && !state.isPreviewMode) {
            const currentSpan = document.getElementById(`word-${state.currentIndex}-${state.currentWordIndex}`);
            if(currentSpan) currentSpan.classList.add('active-word');
            
            updateWordContextUI();
            
            // --- NEW: Update the button label if in Auto Mode ---
            if (state.syncInputMode === 'auto') {
                updateAutoModeLabel();
            }

        } else {
            wordContextUI.classList.remove('visible');
        }
    }

function updateWordContextUI() {
    if(state.mode !== 'word' || !state.lyrics.length || state.isEditMode || state.isPreviewMode) {
        wordContextUI.classList.remove('visible');
        return;
    }
    wordContextUI.classList.add('visible');
    
    const currentLine = state.lyrics[state.currentIndex];
    const currentWord = currentLine ? currentLine.words[state.currentWordIndex] : null;
    
    // Determine UI Layout based on Mode
    // Task 2: "This behavior applies whenever Hold mode is active"
    if (state.syncInputMode === 'hold') {
        
        wordContextUI.classList.add('mode-hold');
        
        // LEFT SIDE: Current Word (Highlighted via CSS)
        ctxPrev.textContent = currentWord ? currentWord.text : "End";
        
        // RIGHT SIDE: Next Word
        let nextWordText = "End of Line";
        
        // Check next word in current line
        if (state.currentWordIndex < currentLine.words.length - 1) {
            nextWordText = currentLine.words[state.currentWordIndex + 1].text;
        } 
        // Or check first word of next line
        else if (state.currentIndex < state.lyrics.length - 1) {
            const nextLine = state.lyrics[state.currentIndex + 1];
            if (nextLine.words.length > 0) {
                nextWordText = nextLine.words[0].text;
            }
        } else {
            nextWordText = "End of Song";
        }
        
        ctxNext.textContent = nextWordText;

    } else {
        // STANDARD TAP / AUTO LAYOUT (Default behavior)
        wordContextUI.classList.remove('mode-hold');

        // LEFT SIDE: Previous Word
        let prevWordText = "...";
        if(state.currentWordIndex > 0) prevWordText = currentLine.words[state.currentWordIndex - 1].text;
        else if(state.currentIndex > 0) {
            const prevLine = state.lyrics[state.currentIndex - 1];
            if(prevLine && prevLine.words.length > 0) prevWordText = prevLine.words[prevLine.words.length - 1].text;
        }
        ctxPrev.textContent = prevWordText;

        // RIGHT SIDE: Current Word (Target)
        ctxNext.textContent = currentWord ? currentWord.text : "End";
    }
}

    // --- Helpers ---
    function formatTimeDisplay(s) {
        if(s < 0) s = 0;
        const m = Math.floor(s / 60);
        const sec = (s % 60).toFixed(2);
        return `${m.toString().padStart(2,'0')}:${sec.toString().padStart(5,'0')}`;
    }
    function formatTimeLRC(s) { return formatTimeDisplay(s); }

    function generateLRC() {
    let out = "";
    
    state.lyrics.forEach((l, i) => {
        // Skip empty timestamp lines unless they are BG lines (which might rely on word timings)
        if (l.time === null && !l.isBg) return;

        if (state.lrcFormat === 'pro') {
            
            // 1. Build Content
            let lineContent = "";
            if (l.words && l.words.length > 0) {
                l.words.forEach((w, idx) => {
                    if (w.start !== null) lineContent += `<${formatTimePro(w.start)}>`;
                    lineContent += w.text;
                    
                    // Space Logic: Add space if not last word AND not ending in dash
                    if (idx < l.words.length - 1) {
                         if (!w.text.endsWith('-')) {
                             lineContent += " "; 
                         }
                    }
                });
                
                const lastWord = l.words[l.words.length - 1];
                if (lastWord && lastWord.end !== null) lineContent += `<${formatTimePro(lastWord.end)}>`;
            } else {
                lineContent += l.text;
            }

            // 2. Output Logic
            if (l.isBg) {
                // FIXED: Always start on a new line. 
                // Do NOT try to append to previous line.
                out += `[bg:${lineContent}]\n`; 
            } else {
                out += `[${formatTimePro(l.time)}]${lineContent}\n`;
            }
        } 
        else {
            // Advanced/Standard Mode (Ignores BG special formatting)
            if (l.time !== null) {
                out += `[${formatTimeLRC(l.time)}]${l.text}\n`;
                if(l.words && l.words.some(w => w.start !== null)) {
                    const tags = l.words.map(w => {
                        const s = w.start ? w.start.toFixed(2) : "";
                        const e = w.end ? w.end.toFixed(2) : "";
                        return `${w.text}:${s}:${e}`;
                    }).join('|');
                    out += `<${tags}>\n`;
                }
            }
        }
    });
    
    exportOutput.value = out;
}
    
    function downloadLRC() {
        generateLRC();
        const blob = new Blob([exportOutput.value], {type:'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${currentFileName}.lrc`; 
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    // --- Keyboard Control ---
    document.addEventListener('keydown', (e) => {
        if(e.target.isContentEditable || e.target.tagName === 'TEXTAREA' || (e.target.tagName === 'INPUT' && e.target.type !== 'range' && e.target.type !== 'file' && e.target.type !== 'radio')) return;
        
        // SPACE: Toggle Play
        if(e.code === 'Space') { e.preventDefault(); togglePlay(); }
        
        // ENTER: Trigger Sync
        if(e.code === 'Enter') { 
            e.preventDefault(); 
            // FIX: Block repeats for Enter key
            if(e.repeat) return;
            handleSyncDown(e);
        }
        
        if(e.code === 'ArrowLeft') { e.preventDefault(); seekAudio(-5); }
        if(e.code === 'ArrowRight') { e.preventDefault(); seekAudio(5); }
    });

    document.addEventListener('keyup', (e) => {
         if(e.target.isContentEditable || e.target.tagName === 'TEXTAREA') return;
         if(e.code === 'Enter') {
             e.preventDefault();
             handleSyncUp(e);
         }
    });
    
    // Init
    updateRangeFill(seekSlider);
    updateSyncUI(); // Set initial labels
    
    // --- Mobile Swipe Gestures ---

    const dockEl = document.querySelector('.control-dock');
    const sidebarEl = document.getElementById('sidebar');
    let touchStartY = 0;
    let touchEndY = 0;

    // 1. Swipe Up on Dock -> Open Settings
    dockEl.addEventListener('touchstart', (e) => {
        touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    dockEl.addEventListener('touchend', (e) => {
        touchEndY = e.changedTouches[0].screenY;
        handleGesture('up');
    }, { passive: true });

    // 2. Swipe Down on Sidebar -> Close Settings
    sidebarEl.addEventListener('touchstart', (e) => {
        touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    sidebarEl.addEventListener('touchend', (e) => {
        touchEndY = e.changedTouches[0].screenY;
        handleGesture('down');
    }, { passive: true });

    function handleGesture(direction) {
        const swipeDistance = touchStartY - touchEndY;
        const threshold = 50; // Minimum pixels to count as a swipe

        if (direction === 'up') {
            // Swipe Up (positive distance) on Dock
            if (swipeDistance > threshold) {
                toggleSettings(true);
            }
        } 
        else if (direction === 'down') {
            // Swipe Down (negative distance) on Sidebar
            // Only close if we are scrolled to the very top to avoid conflict with internal scrolling
            if (sidebarEl.scrollTop === 0 && swipeDistance < -threshold) {
                toggleSettings(false);
            }
        }
    }
    
    // LRC Format Logic
    function setLRCFormat(fmt) {
    state.lrcFormat = fmt;
    
    // Sync UI (Sidebar)
    document.getElementById('fmt-adv-sidebar').checked = (fmt === 'advanced');
    document.getElementById('fmt-pro-sidebar').checked = (fmt === 'pro');

    // Update internal logic variables/UI states
    const tapBtn = document.getElementById('opt-tap');
    const holdBtn = document.getElementById('opt-hold');
    const autoBtn = document.getElementById('opt-sync-auto');

    if (fmt === 'pro') {
        // Pro Constraints
        if (state.mode !== 'word') {
            state.mode = 'word';
            document.getElementById('mode-word').checked = true;
            renderEditor();
        }

        state.syncInputMode = 'auto';
        setGlowMode('auto'); 

        // Update Sync Settings Modal visuals if it exists
        if(tapBtn) {
            tapBtn.classList.remove('active');
            holdBtn.classList.remove('active');
            autoBtn.classList.add('active');
            tapBtn.classList.add('disabled-mode');
            holdBtn.classList.add('disabled-mode');
        }
    } else {
        // Advanced Restore
        if(tapBtn) {
            tapBtn.classList.remove('disabled-mode');
            holdBtn.classList.remove('disabled-mode');
        }
    }
    
    generateLRC();
}
    
    function formatTimePro(s) {
        if (s === null || isNaN(s)) return "00:00.000";
        const m = Math.floor(s / 60);
        const sec = (s % 60);
        // Ensure format mm:ss.ms (3 decimal places)
        return `${m.toString().padStart(2, '0')}:${sec.toFixed(3).padStart(6, '0')}`;
    }
    
    // --- SINGLE LINE EDIT MODAL LOGIC ---

function openSingleLineEditModal(index) {
    editingLineIndex = index;
    const line = state.lyrics[index];
    const modal = document.getElementById('single-line-edit-modal');
    const textArea = document.getElementById('single-line-text');
    
    // FIX: Explicitly get the checkbox by ID
    const bgCheckbox = document.getElementById('edit-line-bg');

    // 1. Setup Text
    textArea.value = line.text;
    
    // 2. Setup Time (Split logic)
    let startTime = line.time;
    if (startTime === null && line.words && line.words.length > 0) {
        const firstSynced = line.words.find(w => w.start !== null);
        if (firstSynced) startTime = firstSynced.start;
    }

    if (startTime !== null) {
        document.getElementById('edit-line-min').value = Math.floor(startTime / 60).toString().padStart(2, '0');
        document.getElementById('edit-line-sec').value = Math.floor(startTime % 60).toString().padStart(2, '0');
        document.getElementById('edit-line-ms').value = Math.round((startTime % 1) * 100).toString().padStart(2, '0');
    } else {
        document.getElementById('edit-line-min').value = "";
        document.getElementById('edit-line-sec').value = "";
        document.getElementById('edit-line-ms').value = "";
    }

    // 3. Setup BG (FIX: Ensure we read the boolean correctly)
    if(bgCheckbox) {
        bgCheckbox.checked = (line.isBg === true);
    }

    modal.classList.add('active');
}

function closeSingleLineEditModal() {
    document.getElementById('single-line-edit-modal').classList.remove('active');
    editingLineIndex = -1;
}

function applySingleLineChanges() {
    if (editingLineIndex === -1) return;
    
    const newText = document.getElementById('single-line-text').value.trim();
    
    // FIX: Read the checkbox state
    const isBg = document.getElementById('edit-line-bg').checked;
    
    // ... (Time calculation logic remains the same) ...
    const m = parseInt(document.getElementById('edit-line-min').value) || 0;
    const s = parseInt(document.getElementById('edit-line-sec').value) || 0;
    const ms = parseInt(document.getElementById('edit-line-ms').value) || 0;
    const hasInput = document.getElementById('edit-line-min').value !== "" || 
                     document.getElementById('edit-line-sec').value !== "";
    const newTime = hasInput ? (m * 60) + s + (ms / 100) : null;
    
    const lineObj = state.lyrics[editingLineIndex];
    
    if (newText !== lineObj.text) {
        lineObj.text = newText;
        lineObj.words = parseWords(newText);
    }
    
    lineObj.time = newTime;
    if (lineObj.words.length > 0 && newTime !== null) {
        lineObj.words[0].start = newTime;
    }

    // FIX: Apply the checkbox state to the object
    lineObj.isBg = isBg;
    
    renderEditor();
    generateLRC();
    closeSingleLineEditModal();
}

function deleteLineFromModal() {
    if (confirm("Delete this line?")) {
        deleteLine(editingLineIndex); // Uses existing delete function
        closeSingleLineEditModal();
    }
}

function addLineFromModal() {
    addLine(editingLineIndex); // Uses existing add function
    // Optional: Switch modal to new line? 
    closeSingleLineEditModal(); 
}

function openViewModal() {
    document.getElementById('view-modal').classList.add('active');
}

function setViewMode(mode) {
    state.viewMode = mode;
    
    // 1. Handle Visuals (Opacity/Active State)
    // Reset all
    document.querySelectorAll('.view-btn').forEach(b => {
        b.classList.remove('active');
        // Reset base styles if they differ (optional, keeps code clean)
        b.classList.add('btn-outline'); 
    });

    // Set Active
    const activeBtn = document.getElementById(`view-btn-${mode}`);
    if(activeBtn) {
        activeBtn.classList.add('active');
        activeBtn.classList.remove('btn-outline'); // Remove outline to show full fill
    }
    
    // 2. Handle Editor Visibility
    appContainer.classList.remove('view-main', 'view-bg');
    if (mode === 'main') appContainer.classList.add('view-main');
    if (mode === 'bg') appContainer.classList.add('view-bg');

    // 3. Close Modal
    document.getElementById('view-modal').classList.remove('active');
    
    // 4. Auto-jump to next valid line
    const nextValid = getNextValidLineIndex(0);
    if (nextValid !== state.currentIndex) {
        state.currentIndex = nextValid;
        state.currentWordIndex = 0;
        updateVisuals();
        scrollToActive();
    }
}

function getNextValidLineIndex(startIndex) {
    let i = startIndex;
    while (i < state.lyrics.length) {
        const line = state.lyrics[i];
        const isBg = !!line.isBg; // ensure boolean

        // If Mode is Main, skip BG lines
        if (state.viewMode === 'main' && isBg) { i++; continue; }
        
        // If Mode is BG, skip non-BG lines
        if (state.viewMode === 'bg' && !isBg) { i++; continue; }

        // If we get here, the line is valid for the current view
        return i;
    }
    return state.lyrics.length; // End of song
}

// Calculate End Time for a line (Crucial for overlap logic)
function getLineEndTime(index) {
    const line = state.lyrics[index];
    if (!line) return 0;

    // 1. If last word has an explicit end time (Pro Mode), use it
    if (line.words && line.words.length > 0) {
        const lastWord = line.words[line.words.length - 1];
        if (lastWord.end !== null) return lastWord.end;
    }

    // 2. Fallback: Estimate based on start of the NEXT line of the SAME type
    // (e.g., Next Main Line for Main, Next BG for BG)
    for (let i = index + 1; i < state.lyrics.length; i++) {
        const next = state.lyrics[i];
        if (!!next.isBg === !!line.isBg && next.time !== null) {
            return next.time;
        }
    }

    // 3. Last Resort: Arbitrary duration (3 seconds)
    return (line.time || 0) + 3.0;
}

// Helper: Applies glow to words within a specific line
function animateWordGlow(lineIdx, curTime) {
    const line = state.lyrics[lineIdx];
    if (!line || !line.words) return;

    for (let w = 0; w < line.words.length; w++) {
        const word = line.words[w];
        if (word.start === null) continue;

        const wordSpan = document.getElementById(`word-${lineIdx}-${w}`);
        if (!wordSpan) continue;

        // Logic: Glow if time has passed word start
        if (word.start <= curTime) {
            if (!wordSpan.classList.contains('preview-glow')) {
                // Apply transition logic
                if (state.glowMode === 'auto' && word.end !== null) {
                    const dur = Math.max(0.1, word.end - word.start);
                    wordSpan.style.transition = `color ${dur}s linear, text-shadow ${dur}s linear, transform 0.2s ease`;
                } else {
                    wordSpan.style.transition = ""; 
                }
                wordSpan.classList.add('preview-glow');
            }
        } else {
            // Future words in active line (handle seeking backwards)
            wordSpan.classList.remove('preview-glow');
            wordSpan.style.transition = ""; 
        }
    }
}

// Helper: Specific cleanup for a single line
function cleanupLineGlow(lineIdx) {
    const line = state.lyrics[lineIdx];
    if (!line || !line.words) return;
    for (let w = 0; w < line.words.length; w++) {
        const wordSpan = document.getElementById(`word-${lineIdx}-${w}`);
        if (wordSpan) {
            wordSpan.classList.remove('preview-glow');
            wordSpan.style.transition = ""; 
        }
    }
}

// Parses a string like "<01:22.333>Word <01:24.444>Word-" into word objects
function parseProWords(rawContent) {
    const tagRegex = /<(\d{2}):(\d{2}(?:\.\d+)?)>/g;
    let words = [];
    let match;
    const timestamps = [];
    
    // 1. Find all timestamps and their positions
    while ((match = tagRegex.exec(rawContent)) !== null) {
        const t = (parseInt(match[1]) * 60) + parseFloat(match[2]);
        timestamps.push({ time: t, index: match.index, length: match[0].length });
    }
    
    // 2. Extract text between timestamps
    for (let i = 0; i < timestamps.length - 1; i++) {
        const current = timestamps[i];
        const next = timestamps[i+1];
        
        // Get raw text segment
        const segment = rawContent.substring(current.index + current.length, next.index);
        let wText = segment.trim();

        if (segment.includes('-') && !wText.includes('-')) {
             wText += '-'; 
        }
        
        if (wText) {
            words.push({ text: wText, start: current.time, end: next.time });
        }
    }
    
    // 3. Handle tail text (after last timestamp)
    const lastTag = timestamps[timestamps.length-1];
    if (lastTag) {
            const tailText = rawContent.substring(lastTag.index + lastTag.length).trim();
            if (tailText) words.push({ text: tailText, start: lastTag.time, end: null });
    }
    
    return words;
}

// --- Sidebar Tabs Logic ---
    function switchTab(tabName) {
        // Update Buttons
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');

        // Update Content
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
    }

    function handleLRCFile(input) {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const text = e.target.result;
            // Put text in box
            document.getElementById('export-output').value = text;
            // Parse it immediately
            parseAndLoadLRC(text);
        };
        reader.readAsText(file);
        input.value = ""; // Reset
    }

    function toggleSettings(show) {
        const sb = document.getElementById('sidebar');
        if(show) {
            sb.classList.add('active');
        } else {
            sb.classList.remove('active');
        }
    }
    
    document.getElementById('edit-settings-btn').onclick = () => toggleSettings(true);

    function setWorkflowDisabled(isDisabled) {
    const sessionTab = document.getElementById('tab-btn-session');
    const outputTab = document.getElementById('tab-btn-output');
    const projectSection = document.getElementById('media-project-section');

    if (isDisabled) {
        sessionTab.classList.add('disabled-area');
        outputTab.classList.add('disabled-area');
        projectSection.classList.add('disabled-area');
        
        if(sessionTab.classList.contains('active') || outputTab.classList.contains('active')) {
            switchTab('media');
        }
    } else {
        sessionTab.classList.remove('disabled-area');
        outputTab.classList.remove('disabled-area');
        projectSection.classList.remove('disabled-area');
    }
}

function initializeEmptyEditor() {
    state.lyrics = [{ text: "Edit this lyrics", time: null, words: parseWords("Edit this lyrics") }];
    state.mode = document.querySelector('input[name="mode"]:checked').value;
    renderEditor();
    toggleSettings(false);
}

document.addEventListener('DOMContentLoaded', () => {
        updateRangeFill(seekSlider);
        updateSyncUI(); 
        state.lyrics = [];
        renderEditor();
});


function openExportModal() {
    generateLRC();
    const previewArea = document.getElementById('export-modal-preview');
    if(previewArea) {
        previewArea.value = document.getElementById('export-output').value;
    }
    document.getElementById('export-modal').classList.add('active');
}

function copyFromExportModal() {
    const previewArea = document.getElementById('export-modal-preview');
    if(previewArea) {
        previewArea.select();
        document.execCommand('copy');
        
        // Visual feedback
        const originalText = "üìã Copy to Clipboard";
        const btn = event.target;
        btn.textContent = "‚úì Copied!";
        setTimeout(() => btn.textContent = originalText, 1500);
    }
}

function makeSep(char) {
        const s = document.createElement('span');
        s.className = 'ts-sep';
        s.textContent = char;
        return s;
}
</script>
</body>
</html>
